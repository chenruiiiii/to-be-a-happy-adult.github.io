<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>03-javascript的运行原理</title>
    <url>/posts/4bc49eeb.html</url>
    <content><![CDATA[<p>上篇博客了解了一下浏览器的运行原理，那javascript的运行原理又是怎么样的呢？</p>
<h1 id="V8引擎"><a href="#V8引擎" class="headerlink" title="V8引擎"></a>V8引擎</h1><p>先来了解一下V8引擎:</p>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image1.png" alt="在这里插入图片描述"></p>
<p>简单来说，V8引擎就是在做<strong>将<code>javascript</code>代码转换成机器语言</strong>，从而被cpu识别继而运行的工作。</p>
<h2 id="执行原理与架构（了解）"><a href="#执行原理与架构（了解）" class="headerlink" title="执行原理与架构（了解）"></a>执行原理与架构（了解）</h2><p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image2.png" alt="在这里插入图片描述"><br>V8引擎本身的源码非常复杂，大概有超过100w行C++代码，通过了解它的架构，我们可以知道它是如何对)vaScript执行的：</p>
<ul>
<li><p><code>Parse</code>：将<code>javascript</code>代码转换成<code>AST抽象语法树</code>，因为解释器并不直接认识js代码；</p>
<ul>
<li>如果函数没有被调用，那么就不会被转成<code>AST</code></li>
</ul>
</li>
<li><p><code>lgnition</code>：是一个解释器，会将<code>AST</code>转换成字节码；</p>
<ul>
<li>同时会收集<code>TurboFan</code>需要的类型信息（比如函数参数的类型信息，有了类型才能进行真实的运算）</li>
<li>如果函数只执行一次，那么将直接解释执行字节码</li>
</ul>
</li>
<li><p><code>TurboFan</code>：是一个编译器，可以将<code>AST</code>转换成CPU直接能运行的机器码；</p>
<ul>
<li>如果一个函数被多次调用，那么将会被标记为<code>热点函数</code>，那么就会经过<code>TurboFan</code>编译成优化的机器码，提高代码的执行性能；</li>
<li>但是，<strong>机器码实际上也会被还原成字节码</strong>，这是因为如果后续执行过程中类型发生了变化，之前优化的机器码并不能正确的运算，就会逆向的转成字节码</li>
</ul>
</li>
</ul>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image3.png" alt="在这里插入图片描述"></p>
<h1 id="javascript-执行过程"><a href="#javascript-执行过程" class="headerlink" title="javascript 执行过程"></a>javascript 执行过程</h1><p>假设现在有段这样的代码，它应该是怎样执行的呢？<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image4.png" alt="在这里插入图片描述"></p>
<p>我们先来了解一下相关的基础知识！</p>
<h2 id="初始化全局对象"><a href="#初始化全局对象" class="headerlink" title="初始化全局对象"></a>初始化全局对象</h2><ul>
<li>首先，<code>js</code> 在执行代码前，会创建一个全局对象：<code>Global Object</code><ul>
<li>该对象 所有的作用域都可以访问；</li>
<li>里面还会包含<code>Date</code>、<code>Array</code>、<code>Number</code>、<code>setTimeout</code>、<code>setInterval</code>等；</li>
<li>其中还有一个属性指向<code>window</code></li>
</ul>
</li>
</ul>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image5.png" alt="在这里插入图片描述"></p>
<h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>js 引擎内部有一个<code>执行上下文栈</code>（Excution Context Stack，简称ECS），是用于执行代码的调用栈。</p>
<ul>
<li><p>那么现在要执行的是谁呢？是全局的代码块：</p>
<ul>
<li>全局的代码块在执行前会创建一个<code>Global Excution Context（GEC）</code>；</li>
<li><code>GEC</code>会被放到<code>ECS</code>中执行</li>
</ul>
</li>
<li><p><code>GEC</code>被放到<code>ECS</code>中包含两部分内容：</p>
<ul>
<li>第一部分：在代码执行前，在<code>parser</code>转成<code>AST</code>的过程中，会将全局定义的变量、函数等加入到<code>Global Object</code>中，但并不会赋值；（这个过程也叫做变量的作用域提升）</li>
<li>在代码执行中，对变量赋值，或者执行其他的函数；</li>
</ul>
</li>
</ul>
<h1 id="全局代码的执行"><a href="#全局代码的执行" class="headerlink" title="全局代码的执行"></a>全局代码的执行</h1><p>先来认识一下<code>VO对象</code>：</p>
<ul>
<li>每个执行上下文都会关联一个VO（Variable Object，变量对象），变量和函数声明会被添加到这个VO对象中；</li>
<li>当全局代码被执行的时候，VO就是GO对象了。</li>
</ul>
<p>❗️❗️❗️问题来了！<strong>全局代码如何被执行呢？</strong></p>
<p><strong>执行前：</strong><br><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image6.png" alt="在这里插入图片描述"><br><strong>执行后：</strong><br><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image7.png" alt="在这里插入图片描述"><br>现在更改代码为：<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image8.png" alt="在这里插入图片描述"></p>
<p>那就又有一个问题：<strong>函数代码如何执行呢？</strong></p>
<h1 id="函数代码的执行"><a href="#函数代码的执行" class="headerlink" title="函数代码的执行"></a>函数代码的执行</h1><ul>
<li>执行代码遇到函数体时，就会根据函数体创建一个函数体上下文（Functional Excution Context），并且压入到ECS中；</li>
<li>当进入函数体执行代码时，就会创建一个<code>AO（Activation Obejct）</code>；</li>
<li>这个<code>AO</code>会使用<code>arguments</code>作为初始化，并且初始值是传入的参数；</li>
<li>这个<code>AO</code>对象会作为该函数体的执行上下文的<code>VO</code>来存放变量的初始化</li>
</ul>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image9.png" alt="在这里插入图片描述"></p>
<p>执行函数上下文之后：</p>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image10.png" alt="在这里插入图片描述"></p>
<p>之后，函数执行上下文将会被压出栈外：</p>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image11.png" alt="在这里插入图片描述"></p>
<p>❗️在函数作用域中可能遇到这样的情况：</p>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image12.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><code>message</code>变量的声明存在于全局作用域，但在局部作用域进行了调用，<strong>那局部作用域又是怎么找到全距作用与中的变量呢？</strong></p>
</blockquote>
<p>这就涉及到了<code>javascript</code>的作用域和作用链！</p>
<h1 id="作用域和作用链"><a href="#作用域和作用链" class="headerlink" title="作用域和作用链"></a>作用域和作用链</h1><p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image13.png" alt="在这里插入图片描述"></p>
<p>上面说到，但我们进入一个执行上下文时，执行上下文会关联一个VO对象，其实，同时它也会关联一个 <strong><code>作用域链（Scope Chain）</code></strong>。</p>
<ul>
<li>作用域链是一个对象列表，用于表示变量标识符的求值；</li>
<li>当进入一个执行上下文时，这个作用域链就会被创建，并且根据代码类型，添加一系列的对象</li>
</ul>
]]></content>
      <categories>
        <category>分类</category>
      </categories>
      <tags>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title>01- this的指向规则</title>
    <url>/posts/d8cbe511.html</url>
    <content><![CDATA[<p><code>this</code> 到底指向谁? 箭头函数中的<code>this</code>还能使用吗? 如果能使用又要怎么使用呢? 与普通函数的<code>this</code>指向一致吗?</p>
<h2 id="this到底指向谁？"><a href="#this到底指向谁？" class="headerlink" title="this到底指向谁？"></a><code>this</code>到底指向谁？</h2><p>首先，定义一个函数：</p>
<p>三种不同的调用方式，this的指向也会不同！</p>
<ol>
<li>直接调用</li>
</ol>
<blockquote>
<p>foo()  &#x2F;&#x2F; window{}</p>
</blockquote>
<ol start="2">
<li>通过对象调用</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var obj = &#123; name: &#x27;name&#x27; &#125;</span><br><span class="line">obj.foo = foo</span><br><span class="line">obj.foo(); // Object&#123;&#125;     (obj这个对象)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>call&#x2F;apply&#x2F;bind</li>
</ol>
<blockquote>
<p>foo.apply(“abc”) &#x2F;&#x2F;  String {‘abc’}</p>
</blockquote>
<p><strong>结论：</strong></p>
<ol>
<li>函数在调用时，js会<strong>默认给this绑定一个值</strong>；</li>
<li>this的绑定跟它**定义的位置（编写的位置）**没有关系；</li>
<li>this的绑定与调用方式以及调用的位置有关；</li>
<li>this是在运行时被绑定的。</li>
</ol>
<h2 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a><code>this</code>的绑定规则</h2><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><ul>
<li>普通函数被独立调用</li>
</ul>
<blockquote>
<p>foo()   &#x2F;&#x2F; window{}</p>
</blockquote>
<ul>
<li>函数定义在对象中，但是独立被调用</li>
</ul>
<blockquote>
<p>var bar &#x3D; obj.foo<br>bar()  &#x2F;&#x2F; window{}</p>
</blockquote>
<ul>
<li><font style="color:#DF2A3F;">严格模式</font>下，独立调用的函数中的<code>this</code>指向<code>undefined</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="meta"></span></span></span><br><span class="line"><span class="meta"><span class="language-javascript">	&quot;use strict&quot;</span></span></span><br><span class="line"><span class="language-javascript">	...</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>高阶函数</li>
</ul>
<blockquote>
<p>function test(fn) {</p>
<pre><code>fn()
</code></pre>
<p>}</p>
<p>test(obj.foo) &#x2F;&#x2F; window{}</p>
</blockquote>
<p>即独立调用函数时(非严格模式下)<code>this</code>指向<code>window</code>!</p>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><blockquote>
<p>一般是通过<strong>对象</strong>来发起调用。</p>
</blockquote>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/01-this-img/image1.png"></p>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/01-this-img/image2.png"></p>
<h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo.<span class="title function_">call</span>(obj)</span><br><span class="line">foo.<span class="title function_">apply</span>(obj) <span class="comment">// foo &#123;name:&#x27;name&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这两种形式的显示绑定区别不大，不会像隐式绑定那样在obj上面添加foo:foo，但是foo的this就指向了obj；</li>
<li>另外，这种形式一般将this绑定在对象身上，如果foo.call(‘abc’)，那么也会默认将’abc’创建为对应的包装类型，这里也就是<code>String</code>对象;</li>
<li>如果是绑定在了<code>undefined</code>这种没有对应包装类型的对象身上，那么this就会默认指向<code>window</code></li>
</ul>
<h4 id="call-apply函数说明"><a href="#call-apply函数说明" class="headerlink" title="call &#x2F; apply函数说明"></a>call &#x2F; apply函数说明</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;参数:&#x27;</span>, name, age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：都可以调取函数并绑定this，传递参数方式不同</p>
<ul>
<li><code>apply(obj,[argumentsArray])</code></li>
</ul>
<p><code>obj</code>是指this指向的对象；</p>
<p><code>argumentsArray</code>是指函数的参数，必须要放在<strong>数组</strong>中进行传递；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// apply</span></span><br><span class="line">test.<span class="title function_">apply</span>(<span class="string">&#x27;apply&#x27;</span>, [<span class="string">&#x27;chenber&#x27;</span>, <span class="number">18</span>]) <span class="comment">// 参数: chenber 18</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;call(obj,arg1,arg2,...)&lt;/font&gt;</code></li>
</ul>
<p><code>obj</code>是指this指向的对象；</p>
<p><code>arg1,arg2,...</code>是指函数的参数列表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call</span></span><br><span class="line">test.<span class="title function_">call</span>(<span class="string">&#x27;call&#x27;</span>, <span class="string">&#x27;chender&#x27;</span>, <span class="number">18</span>) <span class="comment">// 参数: chender 18</span></span><br></pre></td></tr></table></figure>

<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bind</span></span><br><span class="line"><span class="keyword">var</span> bar = test.<span class="title function_">bind</span>(<span class="string">&#x27;bind&#x27;</span>)</span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// 参数:this,String&#123;&#x27;bind&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = test.<span class="title function_">call</span>(<span class="string">&#x27;call&#x27;</span>, <span class="string">&#x27;chender&#x27;</span>, <span class="number">18</span>) <span class="comment">// 参数: chender 18</span></span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p><code>bind</code>是<code>绑定（怪异）函数</code>，是返回绑定过对象的函数，那么在执行的时候this只会指向绑定好的对象；</p>
<p>而<code>call</code>和<code>apply</code>都是直接执行函数，没有返回值 。</p>
<ul>
<li>bind()的其他参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = test.<span class="title function_">call</span>(<span class="string">&#x27;call&#x27;</span>, <span class="string">&#x27;chender&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// 参数: chender 18</span></span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// 参数: chender 18    （参数一开始就指定好了，修改不了）</span></span><br></pre></td></tr></table></figure>

<p>❗️❗️❗️此时，会不会有疑问？（bar()函数单独调用，this不应该指向window吗？）</p>
<p>这里就涉及到了<strong>this绑定的优先级</strong>了！</p>
<ol>
<li>默认绑定优先级最低</li>
<li>显式绑定 &gt; 隐式绑定</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;chenber&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">test</span>: test</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">test</span>.<span class="title function_">apply</span>(<span class="string">&#x27;apply&#x27;</span>, [<span class="string">&#x27;1&#x27;</span>, <span class="number">19</span>]) </span><br><span class="line"><span class="comment">// this [String: &#x27;apply&#x27;]</span></span><br><span class="line"><span class="comment">// 参数: 1 19</span></span><br><span class="line"><span class="keyword">var</span> test1 = obj.<span class="property">test</span>.<span class="title function_">bind</span>(<span class="string">&#x27;bind&#x27;</span>, <span class="string">&#x27;chenber&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="title function_">test1</span>()</span><br><span class="line"><span class="comment">// this [String: &#x27;bind&#x27;]</span></span><br><span class="line"><span class="comment">// 参数: chenber 18</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>new 绑定 &gt; 隐式绑定</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;chenber&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo:&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo:&#x27;</span>, <span class="variable language_">this</span> === obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">foo</span>()</span><br><span class="line"><span class="comment">// foo: foo &#123;&#125;</span></span><br><span class="line"><span class="comment">// foo: false</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>new &gt; 显式(bind)</li>
</ol>
<p>❗️<code>new</code>和<code>apply</code> &#x2F; <code>call</code>不可以一起使用，所以没有可比性</p>
<p><code>new</code>和<code>bind</code>可以一起使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> testFN = test.<span class="title function_">bind</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line">    <span class="keyword">new</span> <span class="title function_">testFN</span>() <span class="comment">// test&#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>使用new关键字来调用函数是，会执行如下的操作：</p>
<ul>
<li>创建一个全新的对象；</li>
<li>这个新对象会被执行prototype连接：</li>
<li>这个新对象会绑定到函数调用的this上（this的绑定在这个步骤完成）；</li>
<li>如果函数没有返回其他对象，表达式会返回这个新对象：</li>
</ul>
<p>总结(优先级从高到低)：</p>
<ol>
<li>new</li>
<li>bind </li>
<li>apply &#x2F; call</li>
<li>隐式</li>
<li>默认绑定</li>
</ol>
<h2 id="内置函数的调用绑定"><a href="#内置函数的调用绑定" class="headerlink" title="内置函数的调用绑定"></a>内置函数的调用绑定</h2><p>内置函数的this指向需要<code>根据一些经验</code>获取</p>
<ol>
<li>setTimeOut()</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setTimeOut</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this&#x27;</span>, <span class="variable language_">this</span>) <span class="comment">//window</span></span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>按钮的点击监听</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">   <span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">   btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;btn&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// &lt;button&gt;点击&lt;/button&gt;</span></span><br><span class="line">   &#125;</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;btn&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// &lt;button&gt;点击&lt;/button&gt;</span></span><br><span class="line">   &#125;)</span><br><span class="line">   btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;btn&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>forEach</li>
</ol>
<p>forEach(function(){}, {})</p>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/01-this-img/image3.png"></p>
<p>forEach的两个参数：</p>
<ol>
<li>回调函数</li>
<li>回调函数的this绑定对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>]</span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;forEach&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;forEach&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// String &#123;&#x27;abc&#x27;&#125;</span></span><br><span class="line">    &#125;, <span class="string">&quot;cba&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="this-绑定之外的规则"><a href="#this-绑定之外的规则" class="headerlink" title="this 绑定之外的规则"></a><code>this</code> 绑定之外的规则</h2><ol>
<li>如果在使用显式绑定时传入<code>null</code>或者<code>undefined</code>，那么就会使用默认绑定规则</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo.<span class="title function_">apply</span>(<span class="literal">null</span>) <span class="comment">// window</span></span><br><span class="line">foo.<span class="title function_">apply</span>(<span class="literal">undefined</span>) <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<p>严格模式差异：在严格模式下，绑定null&#x2F;undefined时会直接使用传入值，this会指向null或undefined本身。</p>
<ol start="2">
<li>间接函数引用（知道就行，一般不会出现）</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line">(obj2.<span class="property">foo</span> = obj.<span class="property">foo</span>)() <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>箭头函数(补充)<br>箭头函数是 <code>es6</code> 新增的一种函数的声明方法。</li>
</ol>
<ul>
<li>完整写法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params">name,age</span>)=&gt;&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;=&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>❗️注:</p>
<pre><code>- 	箭头函数不会绑定`this` 和 `arguments`(有新的属性进行代替)属性；
- 	箭头函数不能作为构造函数来使用（会抛出错误）
</code></pre>
<ul>
<li>箭头函数的简写<ul>
<li>只有一个参数时 可省略()<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/01-this-img/image4.png"></li>
<li>函数体只有一行语句时，可省略{}，但是不能带return 关键字<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/01-this-img/image5.png"></li>
<li>如果执行体只有返回一个对象，那么需要给这个对象加上()<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/01-this-img/image6.png"></li>
</ul>
</li>
</ul>
<h2 id="箭头函数中的-this-使用"><a href="#箭头函数中的-this-使用" class="headerlink" title="箭头函数中的 this 使用"></a>箭头函数中的 <code>this</code> 使用</h2><p> <strong>箭头函数的作用域没有 <code>this</code> ！</strong><br> 但是箭头函数中<code>this</code>会向寻找上层作用域中的<code>this</code>，直至找到全局this-&gt;<code>window</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">test</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>() <span class="comment">// window</span></span><br><span class="line"><span class="keyword">var</span> test1 = test.<span class="title function_">bind</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="title function_">test1</span>() <span class="comment">// window</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;chenber&#x27;</span>,</span><br><span class="line">	<span class="attr">foo</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// window</span></span><br><span class="line"><span class="keyword">const</span> test2 = obj.<span class="property">foo</span>.<span class="title function_">bind</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="title function_">test2</span>() <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<p>应用实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟网络请求函数</span></span><br><span class="line"> <span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">url, callbackFn</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> results = &#123;</span><br><span class="line">     <span class="attr">code</span>: <span class="number">200</span>,</span><br><span class="line">     <span class="attr">msg</span>: <span class="string">&#x27;成功&#x27;</span>,</span><br><span class="line">     <span class="attr">data</span>: <span class="literal">null</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="title function_">callbackFn</span>(results)</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 将获取的数据传输给obj的results</span></span><br><span class="line"> <span class="keyword">var</span> obj = &#123;</span><br><span class="line">   <span class="attr">results</span>: &#123;&#125;,</span><br><span class="line">   <span class="comment">// 之前的写法：</span></span><br><span class="line">   <span class="comment">// getData: function () &#123;</span></span><br><span class="line">   <span class="comment">//   var _this = this</span></span><br><span class="line">   <span class="comment">//   request(&#x27;/test&#x27;, function (res) &#123;</span></span><br><span class="line">   <span class="comment">//     _this.results = res</span></span><br><span class="line">   <span class="comment">//   &#125;)</span></span><br><span class="line">   <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 使用箭头函数:</span></span><br><span class="line">   <span class="attr">getData</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">     <span class="title function_">request</span>(<span class="string">&#x27;/test&#x27;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">results</span> = res</span><br><span class="line">     &#125;)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> obj.<span class="title function_">getData</span>()</span><br></pre></td></tr></table></figure>
<h2 id="1-6-相关面试题"><a href="#1-6-相关面试题" class="headerlink" title="1.6 相关面试题"></a>1.6 相关面试题</h2><ol>
<li>面试题一</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 面试题一</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;person&#x27;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sss = person.<span class="property">sayName</span>;</span><br><span class="line">  <span class="title function_">sss</span>(); <span class="comment">// 默认绑定  输出：window</span></span><br><span class="line"></span><br><span class="line">  person.<span class="title function_">sayName</span>(); <span class="comment">// 隐式绑定  输出：person</span></span><br><span class="line">  (person.<span class="property">sayName</span>)();  <span class="comment">// 隐式绑定  输出：person  // 此处的;不能省略，因为下面是间接函数引用</span></span><br><span class="line">  (b = person.<span class="property">sayName</span>)() <span class="comment">// 默认绑定  输出：window     此处为间接函数引用，相当于独立函数调用，即this指向window </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>面试题二</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 面试题二</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;person1&#x27;</span>,</span><br><span class="line">  <span class="attr">foo1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo2</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>),</span><br><span class="line">  <span class="attr">foo3</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo4</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;person2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo1</span>(); <span class="comment">// 隐式绑定  输出：person1</span></span><br><span class="line">person1.<span class="property">foo1</span>.<span class="title function_">call</span>(person2); <span class="comment">// 显示绑定   输出：person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo2</span>(); <span class="comment">// 默认绑定  输出：window  </span></span><br><span class="line">person1.<span class="property">foo2</span>.<span class="title function_">call</span>(person2); <span class="comment">// 显示绑定  this-&gt;上层作用域  输出：window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上层作用域指的是函数定义时的作用域，而不是函数运行时的作用域   </span></span><br><span class="line"><span class="comment">// 所以下面这几种情况要注意区分</span></span><br><span class="line">person1.<span class="title function_">foo3</span>()(); <span class="comment">// 默认绑定  输出：window </span></span><br><span class="line">person1.<span class="property">foo3</span>.<span class="title function_">call</span>(person2)(); <span class="comment">// 显示绑定  输出：window</span></span><br><span class="line">person1.<span class="title function_">foo3</span>().<span class="title function_">call</span>(person2); <span class="comment">// 显示绑定  输出：person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo4</span>()(); <span class="comment">// 间接函数引用  输出：person1</span></span><br><span class="line">person1.<span class="property">foo4</span>.<span class="title function_">call</span>(person2)(); <span class="comment">// 间接函数引用  输出：person2</span></span><br><span class="line">person1.<span class="title function_">foo4</span>().<span class="title function_">call</span>(person2); <span class="comment">// 显式绑定  输出：person1</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>面试题三<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/01-this-img/image7.png" alt="在这里插入图片描述"></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 面试题三</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo1</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo2</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo3</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo4</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo1</span>(); <span class="comment">// 隐式绑定  输出：person1</span></span><br><span class="line">person1.<span class="property">foo1</span>.<span class="title function_">call</span>(person2); <span class="comment">// 显示绑定  输出：person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo2</span>(); <span class="comment">// 上层作用域查找  输出：person1  </span></span><br><span class="line">person1.<span class="property">foo2</span>.<span class="title function_">call</span>(person2); <span class="comment">// 显示绑定  this-&gt;上层作用域  输出：person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo3</span>()(); <span class="comment">// 默认绑定  输出：window </span></span><br><span class="line">person1.<span class="property">foo3</span>.<span class="title function_">call</span>(person2)(); <span class="comment">// 显式绑定  输出：window</span></span><br><span class="line">person1.<span class="title function_">foo3</span>().<span class="title function_">call</span>(person2); <span class="comment">// 显式绑定  输出：person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo4</span>()(); <span class="comment">// 隐式绑定 上层作用域查找  输出：person1</span></span><br><span class="line">person1.<span class="property">foo4</span>.<span class="title function_">call</span>(person2)(); <span class="comment">// 显式绑定  上层作用域查找  输出：person2</span></span><br><span class="line">person1.<span class="title function_">foo4</span>().<span class="title function_">call</span>(person2); <span class="comment">// 显式绑定  上层作用域查找  输出：person1</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>面试题四<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/01-this-img/image8.png" alt="在这里插入图片描述"></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 面试题四</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">obj</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">foo1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">foo2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo1</span>()()<span class="comment">// 隐式绑定 window</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="property">foo1</span>.<span class="title function_">call</span>(person2)() <span class="comment">// 显式绑定 window</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo1</span>().<span class="title function_">call</span>(person2) <span class="comment">//  显式绑定 person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo2</span>()() <span class="comment">// 隐式绑定 obj</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="property">foo2</span>.<span class="title function_">call</span>(person2)() <span class="comment">// 显式绑定 person2</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo2</span>().<span class="title function_">call</span>(person2) <span class="comment">// 显式绑定 obj</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>分类</category>
      </categories>
      <tags>
        <tag>js高级</tag>
      </tags>
  </entry>
  <entry>
    <title>02- 浏览器运行原理</title>
    <url>/posts/2373884b.html</url>
    <content><![CDATA[<p>从输入路径开始，浏览器是怎样一步步渲染出页面的呢？</p>
<h1 id="网页的解析过程"><a href="#网页的解析过程" class="headerlink" title="网页的解析过程"></a>网页的解析过程</h1><p>输入地址 —&gt; DNS解析 —&gt; 服务器响应 —&gt; 浏览器响应<br>一个网页URL从输入到浏览器中，到显示经历怎样的过程呢？<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image1.png" alt="在这里插入图片描述"></p>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>常见的浏览器内核：<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image2.png" alt="在这里插入图片描述"><br>我们常说的<code>浏览器内核</code>指的是浏览器的<code>排版引擎</code>，也称之为<code>页面渲染引擎</code>或<code>样板引擎</code>。</p>
<h1 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h1><p>详细内容可看我的另一篇博客：<br><a href="https://blog.csdn.net/2302_79523175/article/details/140614526?spm=1011.2415.3001.5331">浏览器渲染原理</a><br><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image3.png" alt="在这里插入图片描述"></p>
<h2 id="解析html"><a href="#解析html" class="headerlink" title="解析html"></a>解析html</h2><p>因为默认情况下服务器会给浏览器返回index..html文件，所以解析HTML是所有步骤的开始：<br>解析HTML，会构建DOM Tree:<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image4.png" alt="在这里插入图片描述"></p>
<h2 id="生成css规则"><a href="#生成css规则" class="headerlink" title="生成css规则"></a>生成css规则</h2><p>浏览器在解析html时遇到 css 的<code>&lt;link&gt;</code>时会开启另外一个线程对css文件进行下载，这也就不会影响到dom tree的生成；<br>下载完css文件后就会对其进行解析，生成对应的<code>cssom</code>树。<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image5.png" alt="在这里插入图片描述"></p>
<h2 id="构建render-tree"><a href="#构建render-tree" class="headerlink" title="构建render tree"></a>构建render tree</h2><p>当有了<code>DOM Tree</code>和<code>CSSOM Tree</code>两部分之后，就可以结合来生成<code>Render Tree</code>了。<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image6.png" alt="在这里插入图片描述"></p>
<p>注意❗️</p>
<ol>
<li><code>link</code>元素不会阻塞<code>DOM Tree</code>的构建，但是会阻塞<code>Render Tree</code>的构建，因为构建<code>Render Tree</code>需要对应的<code>CSSOM Tree</code>；</li>
<li><strong><code>DOM Tree</code>和<code>Render Tree</code>并不是一一对应的</strong>，有些dom可能设置了<code>display: none;</code>，不会在<code>Render Tree</code>中出现。</li>
</ol>
<h2 id="布局-Layout"><a href="#布局-Layout" class="headerlink" title="布局(Layout)"></a>布局(Layout)</h2><p>布局是确定呈现树中所有节点的宽度、高度和位置信息</p>
<p><code>Render Tree</code>形成之后，就可以对dom的style进行计算：</p>
<ol>
<li><code>em</code>、<code>rem</code>或<code>%</code>等转换成<code>px</code>；</li>
<li>…</li>
</ol>
<h2 id="绘制-Paint"><a href="#绘制-Paint" class="headerlink" title="绘制(Paint)"></a>绘制(Paint)</h2><ul>
<li>在绘制阶段，浏览器将布局阶段计算的每个frame转为屏幕上实际的像素点；</li>
<li>包括将元素的可见部分进行绘制，比如文本、颜色、边框、阴影、替换元素（比如img）<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image7.png" alt="在这里插入图片描述"></li>
</ul>
<h1 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h1><h2 id="回流reflow"><a href="#回流reflow" class="headerlink" title="回流reflow"></a>回流reflow</h2><h3 id="（1）理解："><a href="#（1）理解：" class="headerlink" title="（1）理解："></a>（1）理解：</h3><ul>
<li>第一次确定节点的位置和大小叫做布局(Layout)；</li>
<li>之后对于节点大小以及位置等的计算叫做回流。</li>
</ul>
<h3 id="（2）出现情况"><a href="#（2）出现情况" class="headerlink" title="（2）出现情况"></a>（2）出现情况</h3><ol>
<li><code>DOM</code>结构发生改变（添加新节点或者移除节点）；</li>
<li>布局改变（修改了width、height、padding等值）；</li>
<li>窗口resize（修改了窗口的尺寸）；</li>
<li>调用<code>getComputedStyle</code>方法获取尺寸、位置信息；</li>
</ol>
<h2 id="重绘repaint"><a href="#重绘repaint" class="headerlink" title="重绘repaint"></a>重绘repaint</h2><h3 id="（1）理解：-1"><a href="#（1）理解：-1" class="headerlink" title="（1）理解："></a>（1）理解：</h3><ul>
<li>第一次渲染内容叫做绘制(Paint)；</li>
<li>之后重新渲染叫做重绘（repaint）。</li>
</ul>
<h3 id="（2）出现情况-1"><a href="#（2）出现情况-1" class="headerlink" title="（2）出现情况"></a>（2）出现情况</h3><ol>
<li>修改背景色、边框颜色、文字颜色、模糊样式等</li>
<li><code>回流</code>一定引起<code>重绘</code>，所以回流是很<strong>消耗性能</strong>的事情。</li>
</ol>
<p><strong>所以在开发中要尽量避免回流</strong>：</p>
<ol>
<li>修改样式时尽量一次性修改<ul>
<li>比如通过<code>cssText</code>修改，通过添加<code>class</code>修改。</li>
</ul>
</li>
<li>尽量避免频繁的操作DOM<ul>
<li>我们可以在一个<code>DocumentFragment</code>(了解即可)或者是父元素中将要操作的DOM操作完成，在一次性的操作。</li>
</ul>
</li>
<li>尽量避免通过<code>getComputedStyle</code>获取尺寸、位置等信息</li>
<li>对某些元素使用<code>position</code>的<code>absolute</code>或<code>fixed</code><ul>
<li>这种操作并不是不会引起回流，而是相对来说开销较小，不会对其他元素造成影响。</li>
</ul>
</li>
</ol>
<h1 id="特殊解析composite合成-和性能优化"><a href="#特殊解析composite合成-和性能优化" class="headerlink" title="特殊解析composite合成 和性能优化"></a>特殊解析composite合成 和性能优化</h1><p>绘制的过程，浏览器会将布局后的元素绘制到多个合成图层中（这是浏览器的一种优化手段）；</p>
<ul>
<li>默认情况下，标准流的元素会被绘制到同一个图层中；</li>
<li>而某些特殊的属性，会单独创建一个新的合成层，并且新的图层可以使用<code>GPU</code>加速绘制（每个合成层都是单独进行渲染）</li>
</ul>
<p><strong>哪些属性可以形成新的合成层呢</strong>？下面是常见的一下属性：</p>
<ul>
<li>3D transforms</li>
<li><code>video</code>、<code>canvas</code>、<code>iframe</code></li>
<li><code>opacity</code>动画转换</li>
<li><code>position: fixed</code></li>
<li><code>will-cahnge</code>：一个实验性的属性，提前告诉浏览器可能会发生哪些变化</li>
<li><code>animation</code>或<code>transition</code>设置了<code>opacity</code>、<code>transform</code></li>
</ul>
<p>注❗️：<br>分层确实可以提高性能，但是它以内存管理为代价，因此不应作为web性能优化策略的一部分过度使用！</p>
<h1 id="defer和async属性"><a href="#defer和async属性" class="headerlink" title="defer和async属性"></a>defer和async属性</h1><p>首先来了解一下 <strong><code>script</code>和页面解析的关系</strong> !</p>
<p>前面我们已经知道了，浏览器在解析html时遇到<code>&lt;link&gt;</code>不会影响<code>DOM Tree</code>的构建，那遇到<code>&lt;script&gt;</code>呢？会影响吗？<br>答案是：<strong>会的！</strong></p>
<ul>
<li>浏览器在遇到<code>&lt;script&gt;</code>时会先停止对<code>DOM Tree</code>构建，转而去下载、执行js脚本；</li>
<li>只有js脚本执行完毕后，<code>DOM Tree</code>才能继续进行构建；</li>
</ul>
<p>那这是为什么呢？</p>
<ul>
<li>因为js文件中可能存在对<code>DOM</code>的操作；</li>
<li>若先构建<code>DOM Tree</code>，再执行js脚本，可能会造成严重的回流和重绘，影响页面性能。</li>
</ul>
<p>但是这也会带来新的问题，特别是现在主流框架：</p>
<ul>
<li>目前主要流行的<code>Vue</code>、<code>React</code>，脚本往往比html页面更”重”，处理时间更长，</li>
<li>也就是在js脚本执行结束前，页面可能出现空白</li>
</ul>
<p>（有些浏览器可能对此做了优化，也就是在js脚本执行接受之前，先将已经构建的<code>DOM Tree</code>进行展示）<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image8.png" alt="在这里插入图片描述"></p>
<p>为了解决这个问题，<code>&lt;script&gt;</code>给我们提供了两个属性：<code>defer</code>和<code>async</code></p>
<h2 id="4-1-defer"><a href="#4-1-defer" class="headerlink" title="4.1 defer"></a>4.1 defer</h2><ul>
<li>defer会告诉浏览器不要等待脚本的下载，继续执行<code>DOM Tree</code>的构建</li>
<li>脚本的下载有浏览器完成，不会影响<code>DOM Tree</code>的构建；</li>
<li>若脚本先下载完，那它会等待<code>DOM Tree</code>构建完成，在<code>DOMContentLoaded</code>事件执行前执行defer中的代码</li>
</ul>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image9.png" alt="在这里插入图片描述"><br>总结：</p>
<ol>
<li><code>defer</code>不会影响<code>DOM Tree</code>的构建；</li>
<li>在<code>defer</code>中<code>DOM Tree</code>已经构建完成，可进行对dom的操作；</li>
<li><code>defer</code>总是在<code>DOMContentLoaded</code>时间发出前执行；</li>
<li>另外，有多个<code>defer</code>会按照编写顺序执行；</li>
<li>从某种角度来说，<code>defer</code>会提高页面性能，并且推荐放在<code>&lt;head&gt;</code>中（提前下载js脚本）；</li>
<li>注意：<code>defer</code>仅适用于外部脚本，对于<code>&lt;script&gt;</code>默认内容会被忽略。</li>
</ol>
<h2 id="4-2-async"><a href="#4-2-async" class="headerlink" title="4.2 async"></a>4.2 async</h2><ul>
<li><code>async</code>和<code>defer</code>相似，都能够让脚本不堵塞页面；</li>
<li><code>async</code>是完全独立于浏览器的：<ul>
<li>浏览器页面不会因为<code>script</code>脚本而暂停<code>DOM Tree</code>的构建；</li>
<li><code>async</code>脚本不能保证顺序执行脚本，它独立下载，独立运行，不会等待其他脚本；</li>
<li><code>async</code>不一定在<code>DOMContentLoaded</code>时间执行前执行</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong></p>
<ol>
<li><code>defer</code>通常需要在文档解析后操作<code>DOM</code>的<code>javascript</code>代码，并且对多个<code>script</code>文件有顺序要求；</li>
<li><code>async</code>通常用于独立的脚本，对其他脚本，甚至<code>DOM</code>没有依赖的。</li>
</ol>
<p>注：整个JS高级专栏依托于coderwhy老师的课程，相关图片、代码均来自于其课程。</p>
]]></content>
      <categories>
        <category>分类</category>
      </categories>
      <tags>
        <tag>js高级</tag>
      </tags>
  </entry>
</search>

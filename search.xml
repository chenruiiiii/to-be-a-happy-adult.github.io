<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>面试经典题汇总</title>
    <url>/posts/5a01a153.html</url>
    <content><![CDATA[<p><strong>面试经典题汇总</strong>📝</p>
<h1 id="输入网址之后发生了什么？"><a href="#输入网址之后发生了什么？" class="headerlink" title="输入网址之后发生了什么？"></a>输入网址之后发生了什么？</h1><p>我们在浏览器输入网址之后发生了什么，为什么我们能收到这个页面呢？</p>
<h2 id="路径纠错"><a href="#路径纠错" class="headerlink" title="路径纠错"></a>路径纠错</h2><p><strong>第一步❗️路径纠错</strong></p>
<p>我们输入的路径可能有错，也可能缺少协议等东西，就比如我们输入了<code>www..baidu.com</code>，那么浏览器就会自动加上协议，变成<code>http://www.baidu.com</code>，路径补全后变成<code>http://www.baidu.com/</code></p>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p><strong>第二步❗️DNS解析</strong><br>DNS解析，就是把域名解析成IP地址，比如<code>www.baidu.com</code>，那么DNS解析之后，就会变成<code>192.168.3.11</code></p>
<details>
<summary>
❗️这里需要注意DNS缓存和DNS载荷均衡❗️
</summary>
<div>
  <ol>
    <li>DNS缓存
      <ul>
        <li>本地缓存</li>
        <li>浏览器缓存</li>
        <li>系统缓存</li>
      </ul>
    </li>
    <li>
    DNS载荷均衡
      我们知道`DNS解析`后会获取到一个IP地址，这个地址对应网站服务器地址；但是一个大公司可能有上千台服务器，那么返回的到底是哪台服务器呢？
      这里就需要到DNS负载均衡了，所谓的负载均衡是**根据我们的地理位置距离服务器的距离**来决定解析出的IP地址，这样就很好的分散了服务器的压力，提高我们的访问速度。
    </li>
  </ol>
</div>
  
</details>

<h2 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h2><p><strong>第三步❗️TCP连接</strong><br>简单来说，<code>TCP</code>连接就是我们为发送和接受数据建立的通道，而TCP连接的建立需要三次握手和四次挥手。</p>
<p><strong>三次握手</strong></p>
<ol>
<li>客户端向服务端发送一个<code>SYN包</code></li>
<li>服务端在接收到<code>SYN包</code>之后，向客户端发送一个<code>SYN+ACK包</code></li>
<li>客户端在接收到<code>SYN+ACK包</code>之后，向服务端发送一个<code>ACK包</code></li>
</ol>
<p>经过这三次握手，TCP连接就建立起来了。</p>
<h2 id="发送HTTP请求"><a href="#发送HTTP请求" class="headerlink" title="发送HTTP请求"></a>发送HTTP请求</h2><p><strong>第四步❗️发送HTTP请求</strong><br>客户端向服务端发送一个HTTP请求，请求包括请求行，请求头，请求体</p>
<ul>
<li>请求行<ul>
<li>请求方法: GET&#x2F;POST&#x2F;PUT&#x2F;DELETE</li>
<li>请求路径</li>
</ul>
</li>
<li>请求头</li>
<li>请求体（GET请求没有）</li>
</ul>
<h2 id="服务端响应数据"><a href="#服务端响应数据" class="headerlink" title="服务端响应数据"></a>服务端响应数据</h2><p><strong>第五步❗️服务端响应数据</strong><br>服务端接收到http请求后会返回一个http响应：</p>
<ul>
<li>状态行<ul>
<li>响应码</li>
</ul>
</li>
<li>响应头<ul>
<li>content-type: <code>text/html;charset=utf-8</code>等</li>
</ul>
</li>
<li>响应体</li>
</ul>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>关于浏览器渲染可以看这篇博客<a href="https://blog.csdn.net/2302_79523175/article/details/140614526?spm=1011.2415.3001.5331">浏览器渲染原理</a></p>
<h2 id="断开连接"><a href="#断开连接" class="headerlink" title="断开连接"></a>断开连接</h2><p><strong>第六步❗️断开连接</strong></p>
<h1 id="js"><a href="#js" class="headerlink" title="js"></a>js</h1><h2 id="和"><a href="#和" class="headerlink" title="&amp;&amp;  和 ||"></a>&amp;&amp;  和 ||</h2><p><code>数据1 &amp;&amp; 数据2</code>   &#x3D;&#x3D;&#x3D; &gt;  前后依次进行布尔判断</p>
<p><code>数据1 || 数据2</code>   &#x3D;&#x3D;&#x3D; &gt;  前后依次进行布尔判断</p>
<p><strong>最终结果都是返回最后一步判定的数据。</strong></p>
<p>例：</p>
<blockquote>
<p>condole.log(2 &amp;&amp; 3)    &#x2F;&#x2F; 3</p>
<p>console.log(2 || 3)   &#x2F;&#x2F; 2</p>
</blockquote>
<p>常见应用：</p>
<ol>
<li>赋默认值</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = obj.<span class="property">a</span> || <span class="string">&#x27;default&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>函数的调用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> resault = obj.<span class="property">func</span> &amp;&amp; obj.<span class="title function_">func</span>() </span><br></pre></td></tr></table></figure>

<h2 id="深度克隆"><a href="#深度克隆" class="headerlink" title="深度克隆"></a>深度克隆</h2><p>首先明确一下 <code>javascript</code> 的8种数据类型：</p>
<ol>
<li>基本类型：<code>string</code>，<code>number</code>，<code>undefined</code>，<code>boolean</code>，<code>null</code>，<code>symbol</code>，<code>bigint</code></li>
<li>引用类型：<code>object</code></li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">deepClone</span> = (<span class="params">val</span>) =&gt; &#123;</span><br><span class="line">  <span class="comment">// 复杂类型</span></span><br><span class="line">  <span class="comment">// 数组</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="title class_">Array</span>.<span class="title function_">isArray</span>(val)) &#123;</span><br><span class="line">    <span class="keyword">var</span> clone = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; val.<span class="property">length</span>; i++) &#123;</span><br><span class="line">      clone[i] = <span class="title function_">deepClone</span>(val[i])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> &amp;&amp; val !== <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> cloneObj = &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> key <span class="keyword">in</span> val) &#123;</span><br><span class="line">      cloneObj[key] = <span class="title function_">deepClone</span>(val[key])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 基本类型</span></span><br><span class="line">  <span class="keyword">return</span> val</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">deepClone</span>([<span class="number">1</span>, <span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>]));   <span class="comment">// [1, 2, [3, 4], 5]</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">deepClone</span>(&#123; <span class="attr">a</span>: <span class="number">1</span>, <span class="attr">b</span>: <span class="number">2</span>, <span class="attr">c</span>: &#123; <span class="attr">d</span>: <span class="number">3</span>, <span class="attr">e</span>: <span class="number">4</span> &#125; &#125;));  <span class="comment">// &#123; a: 1, b: 2, c: &#123; d: 3, e: 4 &#125; &#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="为什么要有虚拟DOM？"><a href="#为什么要有虚拟DOM？" class="headerlink" title="为什么要有虚拟DOM？"></a>为什么要有虚拟DOM？</h1><p>与原生<code>js</code>比对，现在流行的框架如<code>React</code>、<code>Vue</code>或者<code>Angular</code>都使用了虚拟DOM的设计。当数据发生改变时，会先生成新的虚拟<code>DOM</code>树，经过与旧虚拟<code>DOM</code>树的比对，只更新改变的部分，这极大提高了渲染性能，降低了浏览器的性能浪费。更加完整的解释是这样的：</p>
<ol>
<li><strong>框架设计</strong></li>
</ol>
<p>像那些直接更新<code>DOM</code>的框架，它们的<strong>颗粒度对齐到</strong><code>**DOM**</code><strong>节点</strong>，当数据发生改变的时候，只更新需要更新的节点；</p>
<p>而对于<code>Vue</code>这些框架，它们的<strong>颗粒度对齐到组件</strong>，当数据更新时，整个组件都要重新渲染；如果组件中DOM过多的话，就可能会造成浏览器的多次<strong>重排、重绘</strong>，渲染性能浪费。引入虚拟DOM之后就很大程度的减轻了浏览器的负担。</p>
<ol start="2">
<li><strong>运行环境</strong></li>
</ol>
<p>DOM能在浏览器或<code>node</code>模拟环境中运行，但是在移动端就不能运行（移动端需要的是系统的原生组件）；</p>
<p>但是虚拟DOM会将组件结构生成<code>**js对象**</code>，依据判断出的运行环境给出相应的<code>DOM节点</code>或者<code>原生组件</code>，实现<code>**一套代码，多端复用**</code>(像React Native等)。</p>
<h1 id="js事件循环"><a href="#js事件循环" class="headerlink" title="js事件循环"></a>js事件循环</h1><p>首先要知道js代码的核心是：<code>**单线程和异步任务队列**</code>。</p>
<p>事件循环的核心部分是：<code>调用栈</code>、<code>任务队列(包含宏任务队列和微任务队列)</code>。</p>
<ol>
<li><code>**调用栈**</code>**:**同步代码的执行区。</li>
</ol>
<ul>
<li>第一个宏任务默认为<code>script整块代码</code>，同步执行该代码块，依次放入调用栈，遇到异步任务如<code>setTimeout</code>、<code>Promise.then()</code>等，分别放入微任务和宏任务队列；</li>
<li>调用栈为空时，执行微任务队列内容直至清空；</li>
</ul>
<ol start="2">
<li><code>**任务队列**</code><strong>:</strong></li>
</ol>
<ul>
<li>宏任务: 主要是浏览器或者Nodejs发起的任务。<ul>
<li>script整块代码；</li>
<li>setTimeout、setInterval等</li>
<li>I&#x2F;O操作（如文件读写、网络请求）</li>
<li>事件操作（如click、resize、scroll）</li>
<li>UI渲染</li>
<li>…</li>
</ul>
</li>
<li>微任务：主要是js引擎发起的任务。<ul>
<li>Promise.then&#x2F;catch&#x2F;finally</li>
<li>queneMicroTask（显式微任务）</li>
<li>MutationObserver（DOM变化监听器）</li>
<li>…</li>
</ul>
</li>
</ul>
<p><strong>事件循环过程：</strong></p>
<ol>
<li>第一个宏任务默认为<code>script整块代码</code>，之后默认去除宏任务队列中最早放入的一个执行，同步执行该代码块，依次放入调用栈，遇到异步任务如<code>setTimeout</code>、<code>Promise.then()</code>等，分别放入微任务和宏任务队列；</li>
<li>调用栈为空时，执行微任务队列内容，如果微任务中嵌套微任务，那么就将嵌套的微任务再次放入微任务队列，直至清空；</li>
<li>UI渲染：在微任务清空完，下个宏任务执行前，若有任务引起了DOM的变化，就会引起浏览器的重绘重排；</li>
<li>当UI渲染结束后，本次事件循环结束，执行下个宏任务即为下次事件循环开始；</li>
<li>事件循环是个无限循环的过程，当调用栈和任务队列为空，那么循环结束。</li>
</ol>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>面经</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么要选择 Monorepo ❓</title>
    <url>/posts/ff3db4a4.html</url>
    <content><![CDATA[<p>在软件开发中，代码仓库的管理对项目的开发🧐和协作👥有着很重要的作用。常见的管理方式有<code>Monorepo（单体仓库）</code>和<code>Multirepo（多体仓库）</code>两种。</p>
<h1 id="Multirepo的痛点😖"><a href="#Multirepo的痛点😖" class="headerlink" title="Multirepo的痛点😖"></a><code>Multirepo</code>的痛点😖</h1><p><code>Multirepo</code>是使用单独仓库对单独项目进行管理，项目中的文件被放在不同的仓库中，这正是我们大多数开发所使用的代码管理方式；</p>
<p>痛点：</p>
<ol>
<li><p>依赖问题😖</p>
<p> 如果每个项目代码都安装依赖，都会产生<code>node_modules</code>这样的文件，项目体积变大；</p>
<p> 如果更新依赖需要每个项目都进行更新，其中一个出现错误，其他项目可能也会出现相同的错误❌，需要同时更改多个文件；</p>
</li>
<li><p>重复配置</p>
<p><code>package.json</code>、Eslint、Prettier、Typescript等多种工具或语言的配置需要在每个项目都进行配置，特别麻烦❗️</p>
</li>
<li><p>跨仓库重构困难</p>
<p> 当遇到重构某个接口任务时需要同时修改多个项目的代码，一个简单的重构任务变成了跨仓库的大工程🏗️</p>
</li>
</ol>
<h1 id="Monorepo介绍"><a href="#Monorepo介绍" class="headerlink" title="Monorepo介绍"></a><code>Monorepo</code>介绍</h1><p>而<code>Monorepo</code>是使用一个仓库对多个项目进行管理的项目管理策略，嫩个很好的解决<code>Muitirepo</code>的这些痛点❗️</p>
<ol>
<li><p>共享依赖，统一版本<br><code>Monorepo</code>项目的依赖统一在根目录下，所以相关的项目使用<code>硬链接</code>链接到根目录下的<code>node_modules</code>;</p>
<p>当依赖更新时，所有项目的依赖都会更新，不需要单独更新；</p>
</li>
<li><p>统一配置<br>我们都知道代码环境的配置是很麻烦的，使用<code>Multirepo</code>就需要重复配置多次，而<code>Monorepo</code>只需配置一次就可多个项目共享。</p>
</li>
<li><p>一次重构，原子提交<br>当修改了一个共享工具函数之后，可能需要更新多个地方，但是在<code>Monorepo</code>就可以一次更新（原子提交），就可以同时修改所有依赖它的项目。</p>
</li>
</ol>
<p>比如说一个项目同时有<code>UI</code>组件库，工具库，服务器端代码，客户端代码等多项目代码，那么这个项目的结构就是这样的</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">my-project/</span><br><span class="line">├──  node_modules</span><br><span class="line">├──  ui-compoonents # UI组件库</span><br><span class="line">| ├──<span class="keyword">package</span>.json</span><br><span class="line">├──  utils-library # 工具库</span><br><span class="line">| ├──<span class="keyword">package</span>.json</span><br><span class="line">├──  shared-types # 共享类型</span><br><span class="line">| ├──<span class="keyword">package</span>.json</span><br><span class="line">├──  admin-dashboard # 后台管理</span><br><span class="line">| ├──<span class="keyword">package</span>.json</span><br><span class="line">└──  marketing-site # 官网</span><br><span class="line">| ├──<span class="keyword">package</span>.json</span><br><span class="line">├── pnpm-workspace.yaml</span><br><span class="line">└── <span class="keyword">package</span>.json</span><br></pre></td></tr></table></figure>

<h1 id="创建Monorepo项目"><a href="#创建Monorepo项目" class="headerlink" title="创建Monorepo项目"></a>创建<code>Monorepo</code>项目</h1><p>首先创建项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> my-monorepo</span><br><span class="line"><span class="built_in">cd</span> my-monorepo</span><br><span class="line">pnpm init</span><br></pre></td></tr></table></figure>

<h2 id="🫀核心文件-pnpm-workspace-yaml"><a href="#🫀核心文件-pnpm-workspace-yaml" class="headerlink" title="🫀核心文件 pnpm-workspace.yaml"></a>🫀核心文件 <code>pnpm-workspace.yaml</code></h2><p>接着创建文件<code>pnpm-worspace.yaml</code>，这个是<code>Monorepo</code>的🫀核心文件，它告诉<code>pnpm</code>哪些是要管理的子项目。配置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">packages:</span><br><span class="line">- <span class="string">&#x27;packages/*&#x27;</span></span><br><span class="line">- <span class="string">&#x27;app/*&#x27;</span></span><br></pre></td></tr></table></figure>

<p>得到：</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">my-monorepo/</span><br><span class="line">├── <span class="keyword">package</span>.json</span><br><span class="line">└── pnpm-workspace.yaml</span><br></pre></td></tr></table></figure>

<p>好，现在来创建子项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> packages/utils</span><br><span class="line"><span class="built_in">cd</span> packages/utils</span><br><span class="line">pnpm init</span><br></pre></td></tr></table></figure>

<p>进行<code>packages.json</code>的配置：<br><code>name</code>我们统一配置为<code>@[项目名]/[子项目名]</code>，这样更规范一点</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@my-monorepo/utils&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;packageManager&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pnpm@10.18.3&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>现在可以再创建一个子项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> packages/web-app</span><br><span class="line"><span class="built_in">cd</span> packages/utils</span><br><span class="line">pnpm init</span><br></pre></td></tr></table></figure>

<p>同样地，进行<code>packages.json</code>的配置：<br><code>name</code>我们统一配置为<code>@[项目名]/[子项目名]</code>，这样更规范一点</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;@my-monorepo/web-app&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1.0.0&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;main&quot;</span><span class="punctuation">:</span> <span class="string">&quot;index.js&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;vite --mode dev&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;dependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">     <span class="attr">&quot;@my-monorepo/utils&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workspace:*&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;keywords&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span><span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span><span class="punctuation">:</span> <span class="string">&quot;&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;license&quot;</span><span class="punctuation">:</span> <span class="string">&quot;ISC&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;packageManager&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pnpm@10.18.3&quot;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>像这样，我们直接在子项目中通过<code>dependencies</code>引入，就可以使用了。</p>
<h2 id="增加便捷命令："><a href="#增加便捷命令：" class="headerlink" title="增加便捷命令："></a>增加便捷命令：</h2><p>在根目录下的<code>packages.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;script&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pnpm -F react-app dev&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pnpm -F react-app build&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;preview&quot;</span><span class="punctuation">:</span> <span class="string">&quot;pnpm -F react-app preview&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>这样在根目下就能直接启动某个子项目了。</p>
<p>我们接着来认识一下<code>Turborepo</code>🔧</p>
<h2 id="Turborepo"><a href="#Turborepo" class="headerlink" title="Turborepo"></a><code>Turborepo</code></h2><p><code>Turborepo</code>是<code>Vercel</code>出品的高性能<code>Monorepo</code>构建工具，可以用来管理多项目依赖，并行任务，完美适配React&#x2F;Vue&#x2F;Next.js框架</p>
<p>对比直接使用<code>pnpm</code>，<code>Turborepo</code>的优点有：</p>
<ol>
<li>多任务并行 – 可同时启动多个子项目</li>
<li>构建速度快 – <code>Turborepo</code>有缓存机制，能够更快的启动和打包</li>
<li>…</li>
</ol>
<p>所以更推荐选择使用<code>pnpm</code>+<code>Turborepo</code>来构建和管理我们的<code>Monorepo</code>项目。</p>
<h2 id="引入Turborepo"><a href="#引入Turborepo" class="headerlink" title="引入Turborepo"></a>引入<code>Turborepo</code></h2><p>如果跟我一样先创建了项目，又想使用<code>Turborepo</code>，那么就可以跟着我这样做：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># monorepo 根目录</span></span><br><span class="line">pnpm add -D @turbo/gen turbo -w</span><br></pre></td></tr></table></figure>

<p>接着在根目录<code>package.json</code>中配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;my-monorepo&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;workspace&quot;</span><span class="punctuation">:</span> <span class="punctuation">[</span></span><br><span class="line">    <span class="string">&quot;app/*&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="string">&quot;packages/*&quot;</span></span><br><span class="line">  <span class="punctuation">]</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;dev&quot;</span><span class="punctuation">:</span> <span class="string">&quot;turbo run dev&quot;</span><span class="punctuation">,</span> <span class="comment">// 启动所有项目</span></span><br><span class="line">      <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;turbo run build&quot;</span><span class="punctuation">,</span> <span class="comment">// 构建所有项目</span></span><br><span class="line">      <span class="attr">&quot;dev:web&quot;</span><span class="punctuation">:</span> <span class="string">&quot;turbo run dev --filter=\&quot;&#123;@my-monorepo/web_app&#125;\&quot;&quot;</span><span class="punctuation">,</span> <span class="comment">// 启动@my-monorepo/web_app子项目</span></span><br><span class="line">      <span class="attr">&quot;build:web&quot;</span><span class="punctuation">:</span> <span class="string">&quot;turbo run build --filter=\&quot;&#123;@my-monorepo/web_app&#125;\&quot;&quot;</span> <span class="comment">// 构建@my-monorepo/web_app子项目</span></span><br><span class="line">   <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">   <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;@turbo/gen&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.5.8&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;turbo&quot;</span><span class="punctuation">:</span> <span class="string">&quot;^2.5.8&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>但也可以只配置子项目的<code>package.json</code>，当在根目录执行<code>turbo [xxx]</code>，turbo会自动在所有子项目中<code>package.json</code>中寻找名为<code>...</code>的命令，比如某子包的<code>package.json</code>：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">   <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;start&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts start&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;build&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts build&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;test&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts test&quot;</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;eject&quot;</span><span class="punctuation">:</span> <span class="string">&quot;react-scripts eject&quot;</span></span><br><span class="line">   <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<p>就可以在根目录下执行</p>
<h2 id="在子项目引入工具包"><a href="#在子项目引入工具包" class="headerlink" title="在子项目引入工具包"></a>在子项目引入工具包</h2><p>在子项目<code>package.json</code>中添加依赖：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;devDependencies&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;@my-monorepo/utils&quot;</span><span class="punctuation">:</span> <span class="string">&quot;workspace:*&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>之后执行<code>pnpm install</code>，就会发现依赖已经被链接到<code>node_modules</code>中了。<br><img src="/img.png" alt="img.png"></p>
<h1 id="❗️注意"><a href="#❗️注意" class="headerlink" title="❗️注意"></a>❗️注意</h1><ol>
<li><code>Monorepo</code>结构下所有子项目都必须安装<code>eslint</code>，而且最好在8.x版本，不然可能会有<code>unmet peer</code>警告<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pnpm add eslint@latest -w --save-dev <span class="comment"># 为所有子项目安装eslint到最新版本     -w / --workspace表示“对工作区内所有子包执行安装”</span></span><br><span class="line">npx eslint --init <span class="comment"># 选择 React/TypeScript 等配置，生成 .eslintrc.js</span></span><br><span class="line">pnpm add eslint@8.57.0 --save-dev</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>pnpm</category>
      </categories>
      <tags>
        <tag>Monorepo</tag>
        <tag>pnpm</tag>
      </tags>
  </entry>
  <entry>
    <title>数据类型检测</title>
    <url>/posts/67b93776.html</url>
    <content><![CDATA[<h1 id="数据类型的检测"><a href="#数据类型的检测" class="headerlink" title="数据类型的检测"></a>数据类型的检测</h1><p>❗️首先要明确常见的<strong>八种</strong>数据类型：</p>
<ol>
<li>基本数据类型<ul>
<li><code>string</code></li>
<li><code>number</code></li>
<li><code>boolean</code></li>
<li><code>null</code></li>
<li><code>undefined</code></li>
<li><code>bigint</code></li>
<li><code>symbol</code></li>
</ul>
</li>
<li>复杂数据类型<ul>
<li><code>object</code></li>
</ul>
</li>
</ol>
<h2 id="1-typeof"><a href="#1-typeof" class="headerlink" title="1. typeof"></a>1. <strong>typeof</strong></h2><ul>
<li><strong>typeof</strong> 是一元运算符，用法：<code>typeof value</code></li>
<li>输出值：上面所说的八种类型（除null之外加上个function）</li>
</ul>
<p><strong>注意点</strong>：</p>
<ol>
<li><p><code>typeof null</code> 输出值为Object，这个是历史遗留问题;</p>
</li>
<li><p><code>typeof function()&#123;&#125;</code>输出值为<code>function</code>；</p>
</li>
<li><p><code>[]</code>、<code>&#123;&#125;</code>、<code>function()&#123;&#125;</code>输出值都为<code>Object</code>，也就是<code>typeof</code>只能精准判断除了null之外的基本类型，无法判断复杂数据类型(除function外)；</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">输出值</th>
<th align="center">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><strong>null</strong></td>
<td align="center">object</td>
<td align="center">历史遗留问题</td>
</tr>
<tr>
<td align="center">其他原始类型</td>
<td align="center">对应类型字符串</td>
<td align="center">准确识别</td>
</tr>
<tr>
<td align="center"><strong>function(){}</strong></td>
<td align="center">function</td>
<td align="center">函数属于function类型</td>
</tr>
<tr>
<td align="center"><strong>[] &#x2F; {} &#x2F; Date &#x2F; RegExp等</strong></td>
<td align="center">object</td>
<td align="center">-（无法具体区分object的具体类型）</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="2-instanceof"><a href="#2-instanceof" class="headerlink" title="2. instanceof"></a>2. <strong>instanceof</strong></h2><ul>
<li><strong>instanceof</strong> 是二元运算符，用法：<code>object instanceof type</code></li>
<li>输出值：true 或 false</li>
</ul>
<p><strong>注意点</strong>：</p>
<ol>
<li><code>instanceof </code>是在检测对象的隐式原型链的任意位置是否存在构造函数的原型;</li>
<li>能检测对<strong>Object</strong>的具体类型，如<code>Function</code>、<code>Array</code>、<code>Object</code>等；</li>
</ol>
<h2 id="3-constructor"><a href="#3-constructor" class="headerlink" title="3. constructor"></a>3. <strong>constructor</strong></h2><ul>
<li><strong>constructor</strong> 是对象的构造函数的显式原型上的属性，用法：<code>object.constructor</code></li>
<li>输出值：对象所属的构造函数</li>
</ul>
<p><strong>注意点</strong>：</p>
<ol>
<li><code>constructor</code> 是属性，不是运算符，用法：<code>object.constructor</code></li>
<li><code>constructor</code> 可以进行修改</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = []</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">constructor</span>) <span class="comment">// Array (在obj的隐式原型链上寻找构造函数的原型，再从上面获取constructor属性)</span></span><br><span class="line"></span><br><span class="line">obj.<span class="property">constructor</span> = <span class="title class_">Function</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">constructor</span>) <span class="comment">// Function</span></span><br></pre></td></tr></table></figure>

<h2 id="4-Object-prototype-toString-call"><a href="#4-Object-prototype-toString-call" class="headerlink" title="4. Object.prototype.toString.call()"></a>4. <strong>Object.prototype.toString.call()</strong></h2><p>能准确判断数据类型，包括ES6+出的数据类型(如：<code>Map</code>、<code>Set</code>、<code>WeakSet</code>、<code>WeakMap</code>等)</p>
<h2 id="🚌总结："><a href="#🚌总结：" class="headerlink" title="🚌总结："></a>🚌总结：</h2><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">核心原理</th>
<th align="center">优点</th>
<th align="center">缺点</th>
</tr>
</thead>
<tbody><tr>
<td align="center">typeof</td>
<td align="center">内部类型标志位</td>
<td align="center">推测快速简单</td>
<td align="center">无法检测出[] &#x2F; {}以及对象的具体类型（如Date、RegExp第二个）</td>
</tr>
<tr>
<td align="center">instanceof</td>
<td align="center">检测显示原型是否在对象隐式原型链上</td>
<td align="center">检测对象是否为构造函数实例，支持继承</td>
<td align="center">无法检测原始类型</td>
</tr>
<tr>
<td align="center">constructor</td>
<td align="center">显式原型的构造函数属性</td>
<td align="center">检测是否是某个构造函数的实例</td>
<td align="center">原始类型检测不准确；nul&#x2F;undefined检测会出错；而且<strong>易被修改</strong></td>
</tr>
<tr>
<td align="center">Object.prototype.toString.call</td>
<td align="center">利用Object的固有属性</td>
<td align="center">准确检测类型（包括ES6+新类型）</td>
<td align="center">写法麻烦</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>面经</category>
      </categories>
      <tags>
        <tag>数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程化</title>
    <url>/posts/7db00131.html</url>
    <content><![CDATA[<p>本篇文章主要记录一下<code>前端工程化</code>的一些内容。</p>
<h1 id="项目工程化"><a href="#项目工程化" class="headerlink" title="项目工程化"></a>项目工程化</h1><h2 id="editorconfig-ts"><a href="#editorconfig-ts" class="headerlink" title="editorconfig.ts"></a>editorconfig.ts</h2><p>用来统一团队代码开发风格，即使是不同<code>IDE</code>也遵循一致代码规范。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 根目录标识（必须放在最顶部）</span><br><span class="line">root = true</span><br><span class="line"></span><br><span class="line">[*] # 匹配所有文件</span><br><span class="line">charset = utf-8 # 文件编码（推荐 UTF-8）</span><br><span class="line">end_of_line = lf # 换行符（React 推荐 LF，兼容 Unix/macOS 和现代 Windows）</span><br><span class="line">insert_final_newline = true # 文件末尾自动添加空行</span><br><span class="line">trim_trailing_whitespace = true # 自动删除行尾空白字符</span><br><span class="line">indent_style = space # 缩进使用空格（React 社区主流选择）</span><br><span class="line">indent_size = 2 # 缩进为 2 个空格（JSX/TSX 常用）</span><br><span class="line"></span><br><span class="line"># 针对 JavaScript/TypeScript 文件（.js, .jsx, .ts, .tsx）</span><br><span class="line">[*.&#123;js,jsx,ts,tsx&#125;]</span><br><span class="line">quote_type = single # 引号使用单引号（可选，也可配置为 double）</span><br><span class="line">max_line_length = 100 # 单行最大长度（TS/JS 推荐 100，避免长行）</span><br><span class="line"></span><br><span class="line"># 针对 CSS/SCSS/LESS 文件（.css, .scss, .less）</span><br><span class="line">[*.&#123;css,scss,less&#125;]</span><br><span class="line">indent_size = 2 # 保持与 JS 一致的缩进</span><br><span class="line">quote_type = single # CSS 引号（可选，部分场景用双引号）</span><br><span class="line"></span><br><span class="line"># 针对 JSON 文件（.json）</span><br><span class="line">[*.json]</span><br><span class="line">indent_size = 2 # JSON 推荐 2 空格缩进</span><br><span class="line"></span><br><span class="line"># 针对 Markdown 文件（.md）</span><br><span class="line">[*.md]</span><br><span class="line">trim_trailing_whitespace = false # Markdown 保留行尾空白（如换行符）</span><br><span class="line">max_line_length = 80 # Markdown 正文推荐 80 字符宽度</span><br></pre></td></tr></table></figure>

<h2 id="eslint配置"><a href="#eslint配置" class="headerlink" title="eslint配置"></a>eslint配置</h2><p>创建<code>.eslintconfig.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ... 基础配置（env、parserOptions）</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 插件列表（以 eslint-plugin- 开头，省略前缀）</span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    <span class="string">&#x27;react&#x27;</span>, <span class="comment">// React 基础规则</span></span><br><span class="line">    <span class="string">&#x27;react-hooks&#x27;</span>, <span class="comment">// React Hooks 规则（如闭包陷阱检测）</span></span><br><span class="line">    <span class="string">&#x27;@typescript-eslint&#x27;</span>, <span class="comment">// TypeScript 规则（需配合 @typescript-eslint/parser）</span></span><br><span class="line">    <span class="string">&#x27;import&#x27;</span>, <span class="comment">// 导入/导出规范</span></span><br><span class="line">    <span class="string">&#x27;jsx-a11y&#x27;</span>, <span class="comment">// JSX 可访问性</span></span><br><span class="line">  ],</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 扩展规则集（优先使用推荐规则）</span></span><br><span class="line">  <span class="attr">extends</span>: [</span><br><span class="line">    <span class="comment">// ESLint 官方推荐规则（基础语法）</span></span><br><span class="line">    <span class="string">&#x27;eslint:recommended&#x27;</span>,</span><br><span class="line">    <span class="comment">// React 推荐规则（覆盖 JSX、Hooks 等）</span></span><br><span class="line">    <span class="string">&#x27;plugin:react/recommended&#x27;</span>,</span><br><span class="line">    <span class="comment">// React Hooks 专用规则（必须）</span></span><br><span class="line">    <span class="string">&#x27;plugin:react-hooks/recommended&#x27;</span>,</span><br><span class="line">    <span class="comment">// TypeScript 推荐规则（需在 parserOptions 中指定项目 TS 配置）</span></span><br><span class="line">    <span class="string">&#x27;plugin:@typescript-eslint/recommended&#x27;</span>,</span><br><span class="line">    <span class="comment">// 导入规范规则（如禁止循环依赖、排序）</span></span><br><span class="line">    <span class="string">&#x27;plugin:import/recommended&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;plugin:import/typescript&#x27;</span>, <span class="comment">// TypeScript 导入支持</span></span><br><span class="line">    <span class="comment">// 可访问性规则（可选）</span></span><br><span class="line">    <span class="string">&#x27;plugin:jsx-a11y/recommended&#x27;</span>,</span><br><span class="line">    <span class="comment">// 关闭 Prettier 冲突规则（必须放在最后）</span></span><br><span class="line">    <span class="string">&#x27;plugin:prettier/recommended&#x27;</span>,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="prettier"><a href="#prettier" class="headerlink" title="prettier"></a>prettier</h2><p>使用<code>vite</code>创建文件或者创建<code>vue</code>项目以及使用<code>vscode</code>插件会默认配置代码格式化，但是有些情况可能无法自动格式化代码(比如使用<code>webpack</code>创建项目，或者专用其他软件编写代码)，所以配置一下<code>prettier</code>比较规范.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm i prettier -D</span><br><span class="line">pnpm add prettier -D</span><br></pre></td></tr></table></figure>

<p>创建<code>.prettierrc</code>和<code>.prettierignore</code>两个文件</p>
<ul>
<li><code>.prettierrc</code> # 格式化run time 配置  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;semi&quot;: true, // 保留分号</span><br><span class="line">    &quot;singleQuote&quot;: true, // 单引号</span><br><span class="line">    &quot;tabWidth&quot;: 2, // 2 空格缩进</span><br><span class="line">    &quot;useTabs&quot;: false, // 不用 Tab</span><br><span class="line">    &quot;trailingComma&quot;: &quot;all&quot;, // 所有可能的位置加尾随逗号（ES5+）</span><br><span class="line">    &quot;printWidth&quot;: 100, // 单行最大 100 字符</span><br><span class="line">    &quot;jsxSingleQuote&quot;: true, // JSX 用单引号</span><br><span class="line">    &quot;bracketSpacing&quot;: true, // 对象括号加空格：&#123; key: value &#125;</span><br><span class="line">    &quot;arrowParens&quot;: &quot;always&quot;, // 箭头函数参数加括号：(param) =&gt; &#123;&#125;</span><br><span class="line">    &quot;overrides&quot;: [ // 针对特定文件覆盖规则</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;files&quot;: &quot;*.md&quot;, // Markdown 文件</span><br><span class="line">            &quot;options&quot;: &#123;</span><br><span class="line">                &quot;printWidth&quot;: 80, // Markdown 单行限制 80 字符</span><br><span class="line">                &quot;proseWrap&quot;: &quot;preserve&quot; // 保留原换行</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;files&quot;: &quot;*.html&quot;, // HTML 文件</span><br><span class="line">            &quot;options&quot;: &#123;</span><br><span class="line">                &quot;htmlWhitespaceSensitivity&quot;: &quot;ignore&quot; // 忽略 HTML 空白</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>.prettierignore</code> # 格式化忽略文件  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 构建输出目录</span><br><span class="line">dist/</span><br><span class="line">build/</span><br><span class="line">out/</span><br><span class="line"></span><br><span class="line"># 依赖目录</span><br><span class="line">node_modules/</span><br><span class="line"></span><br><span class="line"># 静态资源</span><br><span class="line">public/</span><br><span class="line">assets/</span><br><span class="line">images/</span><br><span class="line">fonts/</span><br><span class="line">icons/</span><br><span class="line"></span><br><span class="line"># 配置文件</span><br><span class="line">.env</span><br><span class="line">.env.local</span><br><span class="line">.env.development</span><br><span class="line">.env.production</span><br><span class="line">.editorconfig</span><br><span class="line">.eslintrc.js</span><br><span class="line">.prettierrc.js</span><br><span class="line"></span><br><span class="line"># 测试/覆盖率报告</span><br><span class="line">coverage/</span><br><span class="line">.nyc_output/</span><br><span class="line">*.test.js</span><br><span class="line">*.spec.tsx</span><br><span class="line"></span><br><span class="line"># IDE/编辑器缓存</span><br><span class="line">.vscode/</span><br><span class="line">.idea/</span><br><span class="line">*.suo</span><br><span class="line">*.ntvs*</span><br><span class="line">*.njsproj</span><br><span class="line">*.sln</span><br><span class="line"></span><br><span class="line"># 其他</span><br><span class="line">*.log</span><br><span class="line">*.tmp</span><br><span class="line">.DS_Store</span><br></pre></td></tr></table></figure></li>
</ul>
<p>一次性格式化多个文件命令配置：</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;prettier&quot;</span><span class="punctuation">:</span> <span class="string">&quot;prettier --write .&quot;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>工程化</category>
      </categories>
      <tags>
        <tag>eslint</tag>
        <tag>prettier</tag>
      </tags>
  </entry>
  <entry>
    <title>项目性能优化</title>
    <url>/posts/345bc23f.html</url>
    <content><![CDATA[<p>项目整体需求大致完成后，需要开始进行项目性能优化了，优化思路主要有：<code>首屏加载</code>、<code>交互优化</code>等</p>
<h1 id="图片加载白屏"><a href="#图片加载白屏" class="headerlink" title="图片加载白屏"></a>图片加载白屏</h1><p>首屏如果有很多图片需要加载，那么大概率会出现白屏的情况，下面从打包-&gt;加载资源-&gt;加速网络传输进行解决，主要分为：</p>
<h2 id="减少资源体积"><a href="#减少资源体积" class="headerlink" title="减少资源体积"></a>减少资源体积</h2><p><code>webpack</code>和<code>vite</code>都有对应的插件可以使用</p>
<ul>
<li><code>vite</code> — <code>vite-plugin-imagemin</code><ul>
<li>首先要明白，在打包时，<code>**vite**</code><strong>会对</strong><code>**src**</code><strong>或项目根目录下的图片进行压缩或其他处理，但对于</strong><code>**public**</code><strong>下的图片，</strong><code>vite</code>会绕过插件的处理，只对其进行复制处理；也就是说如果直接在项目中使用<code>public</code>中的图片，同时文件又特别大的情况下，那么出现白屏是必然的；</li>
<li>常见配置：</li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// vite.config.js</span><br><span class="line">import &#123; defineConfig &#125; from <span class="string">&#x27;vite&#x27;</span>;</span><br><span class="line">import imagemin from <span class="string">&#x27;vite-plugin-imagemin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default defineConfig(&#123;</span><br><span class="line">  plugins: [</span><br><span class="line">    imagemin(&#123;</span><br><span class="line">      gifsicle: &#123; optimizationLevel: 3 &#125;, // GIF 压缩</span><br><span class="line">      mozjpeg: &#123; quality: 75 &#125;, // JPEG 有损压缩（质量 75%）</span><br><span class="line">      pngquant: &#123; quality: [0.8, 0.9] &#125;, // PNG 有损压缩（质量区间）</span><br><span class="line">      svgo: &#123; plugins: [&#123; removeViewBox: <span class="literal">false</span> &#125;] &#125;, // SVG 优化（保留 viewBox）</span><br><span class="line">      webp: &#123; quality: 80 &#125;, // 转换为 WebP（可选）</span><br><span class="line">    &#125;),</span><br><span class="line">  ],</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>webpack</code> — <code>&lt;font style=&quot;color:rgba(0, 0, 0, 0.9);&quot;&gt;image-webpack-loader&lt;/font&gt;</code><ul>
<li>npm i <font style="color:rgba(0, 0, 0, 0.9);">image-webpack-loader –sace-dev</font></li>
</ul>
</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">// webpack.config.ts</span><br><span class="line">module.exports = &#123;</span><br><span class="line">  module: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">test</span>: /\.(png|jpe?g|gif|webp|avif|svg)$/i,</span><br><span class="line">        <span class="built_in">type</span>: <span class="string">&#x27;asset&#x27;</span>, // 自动处理为资源文件</span><br><span class="line">        parser: &#123;</span><br><span class="line">          dataUrlCondition: &#123;</span><br><span class="line">            maxSize: 8 * 1024, // 超过 8KB 转为外部文件，否则 Base64 内联</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        generator: &#123;</span><br><span class="line">          filename: <span class="string">&#x27;images/[name]-[hash][ext]&#x27;</span>, // 输出路径和文件名</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">test</span>: /\.(png|jpe?g|gif|webp|avif|svg)$/i,</span><br><span class="line">        use: [</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;file-loader&#x27;</span>, // 或直接用 Asset Modules</span><br><span class="line">            options: &#123; name: <span class="string">&#x27;images/[name]-[hash].[ext]&#x27;</span> &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">          &#123;</span><br><span class="line">            loader: <span class="string">&#x27;image-webpack-loader&#x27;</span>,</span><br><span class="line">            options: &#123;</span><br><span class="line">              mozjpeg: &#123; progressive: <span class="literal">true</span>, quality: 75 &#125;, // JPEG 渐进式加载+压缩</span><br><span class="line">              optipng: &#123; enabled: <span class="literal">false</span> &#125;, // 关闭 optipng（用 pngquant 替代）</span><br><span class="line">              pngquant: &#123; quality: [0.8, 0.9], speed: 4 &#125;, // PNG 压缩</span><br><span class="line">              gifsicle: &#123; interlaced: <span class="literal">false</span> &#125;, // GIF 不交错</span><br><span class="line">              webp: &#123; quality: 80 &#125;, // 转换为 WebP（需配合其他工具）</span><br><span class="line">            &#125;,</span><br><span class="line">          &#125;,</span><br><span class="line">        ],</span><br><span class="line">        <span class="built_in">type</span>: <span class="string">&#x27;javascript/auto&#x27;</span>, // 避免与 Asset Modules 冲突（若使用 file-loader）</span><br><span class="line">      &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="加载资源"><a href="#加载资源" class="headerlink" title="加载资源"></a>加载资源</h2><h3 id="懒加载非关键图片"><a href="#懒加载非关键图片" class="headerlink" title="懒加载非关键图片"></a>懒加载非关键图片</h3><p>懒加载并不能提高首屏速度，只能优化用户体验；</p>
<ul>
<li>图片<ul>
<li><img src="..." alt="替代文本" rel="preload"/></li>
<li>结合<code>intersectionObserver</code>监听滚动事件</li>
<li>也可以使用第三方库<code>lozad.js</code>（轻量级，支持图片&#x2F;iframe）</li>
</ul>
</li>
</ul>
<h3 id="关键图片预加载"><a href="#关键图片预加载" class="headerlink" title="关键图片预加载"></a>关键图片预加载</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;<span class="built_in">link</span> rel=<span class="string">&quot;preload&quot;</span> href=<span class="string">&quot;image.webp&quot;</span> as=<span class="string">&quot;image&quot;</span>&gt;</span><br></pre></td></tr></table></figure>

<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><p>即使做了前面的处理，也有可能还是出现首屏加载慢的情况，所以还可以对静态资源进行托管或缓存处理。</p>
<p>这部分一般都是<strong>部署</strong>的时候进行；</p>
<h3 id="CDN加速"><a href="#CDN加速" class="headerlink" title="CDN加速"></a>CDN加速</h3><p>将静态资源托管到服务器（例：jsDeliver，阿里云OSS）</p>
<h3 id="缓存策略"><a href="#缓存策略" class="headerlink" title="缓存策略"></a>缓存策略</h3><p>设置HTTP缓存头，再次访问时直接读取本地资源，无需再次下载。</p>
<ul>
<li><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;Cache-Control: max-age=31536000, immutable&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">：图片缓存 1 年（immutable 表示内容不变，避免重复验证）；</font></li>
<li><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;ETag&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">&#x2F;</font><code>&lt;font style=&quot;color:rgb(0, 0, 0);&quot;&gt;Last-Modified&lt;/font&gt;</code><font style="color:rgb(0, 0, 0);">：资源更新时，浏览器自动重新请求。</font></li>
</ul>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title>git常见问题解决</title>
    <url>/posts/490dde0b.html</url>
    <content><![CDATA[<h1 id="Git常见问题解决"><a href="#Git常见问题解决" class="headerlink" title="Git常见问题解决"></a>Git常见问题解决</h1><h2 id="首次添加远程仓库"><a href="#首次添加远程仓库" class="headerlink" title="首次添加远程仓库"></a>首次添加远程仓库</h2><blockquote>
<p><strong>场景：本地分支已存在，远程分支也已存在，但未建立联系</strong></p>
</blockquote>
<p>首次添加远程仓库时，我们的本地分支与远程分支未能建立联系，从本地<code>master</code>切换到<code>远程master</code>时会出现<code>Git:fatal:a branch named &#39;master&#39;already exists</code>的错误！</p>
<ol>
<li><p>查看当前分支<br>查看当前位于什么分支，保证下面之后操作的分支正确；</p>
</li>
<li><p>与远程分支建立联系<br>将当前分支与远程origin&#x2F;master分支建立联系</p>
<blockquote>
<p>git branch –set-upstream-to&#x3D;origin&#x2F;master</p>
<p>简写：git branch -u origin&#x2F;master</p>
</blockquote>
</li>
<li><p>查看是否建立联系</p>
<blockquote>
<p>查看所有分支的状态</p>
<p>git branch -vv<br>查看当前分支的状态<br>git status</p>
</blockquote>
<p><img src="/../../img/Git/img_12.png" alt="img.png"></p>
</li>
<li><p>解决之后的错误<br>之后可能会出现<code>fatal: refusing to merge unrelated histories</code>的问题，解决方法如下：</p>
</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin master --allow-unrelated-histories</span><br></pre></td></tr></table></figure>

<p>这样问题就基本解决了！</p>
<h2 id="connection-abort"><a href="#connection-abort" class="headerlink" title="connection abort"></a>connection abort</h2><p>有时候使用ssh方式推送代码的时候会出现下面的错误😅：</p>
<p><img src="/../../img/Git/img_13.png" alt="img.png"></p>
<p><span style="color: red;">原因<span>：</p>
<p>代理服务商为了安全考虑，避免被别人当跳板，会限制22端口的连接，导致无法正确连接到Github的服务器。</p>
<p><strong>解决办法：</strong><br>改走HTTPS协议，走443端口，这样不仅可以解决上面的问题，还可以提高代理的下载速度。<br>在<code>~/.ssh/config</code>中添加以下内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">    Hostname ssh.github.com</span><br><span class="line">    Port 443</span><br><span class="line">    User git</span><br></pre></td></tr></table></figure>
<p>之后就可以正常拉取推送了！</p>
<h2 id="Failed-to-connect-to-127-0-0-1"><a href="#Failed-to-connect-to-127-0-0-1" class="headerlink" title="Failed to connect to 127.0.0.1"></a>Failed to connect to 127.0.0.1</h2><p>有时候可能会出现下面的错误❌：<br><img src="/../../img/Git/img_14.png" alt="img.png"></p>
<p>查看git有没有proxy</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy</span><br><span class="line">git config --global https.proxy</span><br></pre></td></tr></table></figure>
<p>如果有代理，取消之后就可以正常拉取推送了！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure>

<h2 id="refusing-to-merge-unrelated-histories"><a href="#refusing-to-merge-unrelated-histories" class="headerlink" title="refusing to merge unrelated histories"></a>refusing to merge unrelated histories</h2><p>刚学习使用git的时候可能会犯的错就是：本地<code>git init</code>了仓库，远程仓库同样也初始化了，这就会导致两个仓库的历史提交是完全独立的。</p>
<p>一个<code>Git</code>仓库好比是一棵树，树上的每个节点就是一次提交。正常情况下，当在一个仓库中工作，操作也都是在同一棵树上不同的分支上进行推送和拉取。<code>Git</code>可以轻松的追踪这些分支的演变，因为他们都来自同一个根（即最初的提交）。</p>
<p>但是如果出现“不相关的历史记录”，就好像把两颗长在不同地方的树进行合并，<code>Git</code>无法找到共同的起点来理解这两个库的关系，所以会拒绝执行合并。</p>
<p><strong>解决办法：</strong></p>
<ol>
<li>常见方法：<code>--allow-unrelated-histories</code> 强制执行合并 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull origin &lt;branch_name&gt; --allow-unrelated-histories</span><br></pre></td></tr></table></figure></li>
<li>新项目中<br>如果是在新项目中，我们可以先<code>git clone</code>把仓库代码拉到本地，之后在克隆的仓库中拉取和推送。这样可以确保本地仓库在一开始就跟远程仓库拥有相同的历史。</li>
</ol>
<h2 id="携带未提交的更改到另外分支"><a href="#携带未提交的更改到另外分支" class="headerlink" title="携带未提交的更改到另外分支"></a>携带未提交的更改到另外分支</h2><p>在改项目代码的时候添加了新功能一些的尝试，但是尝试还需要很长时间才能完成，这时候还有其他需求等待完成，所以不得需要先将更改保存起来（放入其他分支）</p>
<p>我们可以通过<code>stash</code>暂时保存当前更改，切换到其他分支之后再恢复更改；</p>
<ol>
<li><p>保存更改到<code>stash</code>条目</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash save <span class="string">&quot;临时保存dev-添加列表滚动加载&quot;</span> <span class="comment"># 可选：添加描述信息</span></span><br><span class="line"><span class="comment"># 或者简化命令</span></span><br><span class="line">git stash push -m <span class="string">&quot;临时保存dev-添加列表滚动加载&quot;</span></span><br></pre></td></tr></table></figure>
<p>保存更改的时候注意<code>components.d.ts</code>，它会阻碍其他文件提交到<code>stash</code>(本来一次<code>stash</code>就可以了，因为这个文件会多几次<code>stash</code>)</p>
</li>
<li><p>切换分支21</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -m feature-scrollbar</span><br></pre></td></tr></table></figure>
</li>
<li><p>从<code>stash</code>恢复到当前分支</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git stash pop <span class="comment"># 获取最新stash条目并删除</span></span><br><span class="line">git stash apply stash@&#123;0&#125; <span class="comment"># 只获取不删除</span></span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 分布式版本控制工具</title>
    <url>/posts/92d95aa4.html</url>
    <content><![CDATA[<h1 id="Git-概述"><a href="#Git-概述" class="headerlink" title="Git 概述"></a>Git 概述</h1><h2 id="Git-版本控制器的方式"><a href="#Git-版本控制器的方式" class="headerlink" title="Git 版本控制器的方式"></a>Git 版本控制器的方式</h2><ul>
<li><p><strong><code>集中式版本控制</code></strong></p>
<blockquote>
<p>集中式版本控制工具的版本库是集中放置在中央服务器的，团队中的每个人先从版本库中下载代码（需要联网才能工作），个人修改后提交到中央版本库。<br>例：<code>SVN</code> 和 <code>CVS</code> </p>
</blockquote>
</li>
<li><p><strong><code>分布式版本控制</code></strong></p>
<blockquote>
<p>分布式版本控制系统没有“中央版本库”，每个人电脑上都是一个完整的版本库，这样工作的时候就不需要联网了。版本都在自己电脑上，修改后只要提交到仓库就可以实现多人协作。<br>例：<code>Git</code></p>
</blockquote>
</li>
</ul>
<h2 id="Git-工作流程"><a href="#Git-工作流程" class="headerlink" title="Git 工作流程"></a>Git 工作流程</h2><p><img src="/../../img/Git/img.png" alt="img.png"><br><strong>相关命令：</strong></p>
<ol>
<li><code>clone（克隆）</code>：从仓库代码中克隆代码到本地仓库</li>
<li><code>checkout（检出）</code>：从本地仓库检出一个分支进行修订(也就是切换分支)</li>
<li><code>add（添加）</code>：将修改的文件添加到暂存区</li>
<li><code>commit（提交）</code>：将暂存区中的文件提交到本地仓库</li>
<li><code>fetch（抓取）</code>：从远程库住去到本地仓库，不进行其他的合并动作</li>
<li><code>pull（拉取）</code>：从远程库拉取最新代码，自动进行合并(merge)，相当于<code>fetch</code>和<code>merge</code></li>
<li><code>push（推送）</code>：将本地仓库推送到远程仓库</li>
</ol>
<h1 id="Git-安装与常用命令"><a href="#Git-安装与常用命令" class="headerlink" title="Git 安装与常用命令"></a>Git 安装与常用命令</h1><p>常用Linux命令：</p>
<ol>
<li>ll &#x2F; ls：查看当前目录下的文件</li>
<li>cat：查看文件内容</li>
<li>touch：创建文件</li>
</ol>
<h2 id="Git-环境配置"><a href="#Git-环境配置" class="headerlink" title="Git 环境配置"></a>Git 环境配置</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><blockquote>
<p>安装地址：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a></p>
</blockquote>
<p>傻瓜式安装后后见点击桌面出现图示红框中内容即为成功安装。<br><img src="/../../img/Git/img_1.png" alt="img_1.png"></p>
<p><strong>注：</strong><br><code>Git GUI</code>：Git图形化管理工具<br><code>Git Bash</code>：Git命令行工具</p>
<h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>安装完Git后首先是要全局配置email和用户名，每次提交代码时都会使用到！全局配置可以省去每次提交代码时都要输入email和用户名</p>
<ol>
<li><p>设置用户信息</p>
<blockquote>
<p>git config–global user.name “你的用户名”</p>
</blockquote>
<blockquote>
<p>git config–global user.email “你的邮箱”</p>
</blockquote>
</li>
<li><p>查看用户信息</p>
<blockquote>
<p>git config–global user.name</p>
</blockquote>
<blockquote>
<p>git config–global user.email</p>
</blockquote>
</li>
</ol>
<h3 id="常用命令配置"><a href="#常用命令配置" class="headerlink" title="常用命令配置"></a>常用命令配置</h3><ol>
<li><p>打开电脑用户目录：C:\Users\你的用户名</p>
<blockquote>
<p>部分windows用户不允许用户创建点号开头的文件，可以打开<code>gitbash</code>执行: <code>touch ~/.bashrc</code></p>
</blockquote>
</li>
<li><p>在<code>.bashrc</code>文件中添加如下内容：</p>
<blockquote>
<p>用于输出git提交日志<br>alias git-log&#x3D;”git log –pretty&#x3D;oneline –all –graph –abbrev-commit”  </p>
</blockquote>
</li>
<li><p>打开gitBash，执行<code>source ~/.bashrc</code><br><img src="/../../img/Git/img_2.png" alt="img_2.png"></p>
</li>
</ol>
<h3 id="解决Git乱码问题"><a href="#解决Git乱码问题" class="headerlink" title="解决Git乱码问题"></a>解决Git乱码问题</h3><p><img src="/../../img/Git/img_3.png" alt="img_3.png"></p>
<h2 id="获取本地仓库"><a href="#获取本地仓库" class="headerlink" title="获取本地仓库"></a>获取本地仓库</h2><p>在工作目录打开git bash 输入<code>git init</code>，若出现.git文件夹这证明获取本地仓库成功。</p>
<h2 id="基础操作指令"><a href="#基础操作指令" class="headerlink" title="基础操作指令"></a>基础操作指令</h2><p>Git工作目录下对于文件的修改（新增、更新、删除）会存在几种状态，这些修改的状态会随着我们执行Git命令而发生改变。<br><img src="/../../img/Git/img_6.png" alt="img_6.png"></p>
<ol>
<li><p><strong>查看修改状态</strong>  —  查看修改的状态（暂存区、工作区）</p>
<blockquote>
<p>git status</p>
</blockquote>
</li>
<li><p><strong>添加工作区到暂存区</strong></p>
<blockquote>
<p>将文件提交到当前仓库的暂存区<br>git add 文件名 | 通配符<br>例：git add ‘file01.txt’    或者    git add .</p>
</blockquote>
</li>
<li><p><strong>提交暂存到本地仓库</strong></p>
<blockquote>
<p>将暂存区中的文件提交到当前仓库的当前分支<br>git commit -m ‘提交信息’</p>
</blockquote>
<p> <img src="/../../img/Git/img_8.png" alt="img_8.png"></p>
</li>
<li><p><strong>查看提交日志</strong></p>
<blockquote>
<p>git log [options]</p>
</blockquote>
<blockquote>
<p>options:</p>
</blockquote>
<pre><code>  &gt; --all  输出全部的提交日志
  &gt; --pretty=oneline  提交日志在一行输出
  &gt; --abbrev-commit  使得输出的commitId更简短
  &gt; --graph  提交日志以图的形式显示
</code></pre>
</li>
<li><p>版本回退</p>
<blockquote>
<p>git reset –hard commitId    （commitId可以通过<code>git log</code>或者之前设置的<code>git-log</code>进行查看）</p>
</blockquote>
<blockquote>
<p>如何查看已经删除的记录<br>git reflog</p>
</blockquote>
<p> <img src="/../../img/Git/img_10.png" alt="img_10.png"></p>
</li>
<li><p>添加文件到忽略列表<br> 工作目录中的有些文件无需纳入到git仓库中，比如node_modules等文件，这时我们可以新建一个<code>.gitignore</code>文件，将需要忽略的文件名写入到该文件中即可。下面是一个<code>.gitignore</code>文件示例：<br> <img src="/../../img/Git/img_9.png" alt="img_9.png"></p>
</li>
</ol>
<h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><p>使用分支以意味着你可以把你的工作从开发主线上分离开来进行重大的bug修改、开发新的功能，以免影响主线开发。</p>
<h3 id="分支常用命令"><a href="#分支常用命令" class="headerlink" title="分支常用命令"></a>分支常用命令</h3><ol>
<li><p>查看分支</p>
<ul>
<li><code>git branch</code></li>
</ul>
</li>
<li><p><strong>创建分支</strong></p>
<ul>
<li><code>git branch 分支名</code></li>
</ul>
</li>
<li><p>上面我们所配置的命令别名<code>git-log</code></p>
</li>
<li><p>切换分支</p>
<ul>
<li><code>git checkout 分支名</code>   </li>
<li><code>git checkout -b 分支名</code>(可直接切换到一个不存在的分支名，Git会自动创建一个分支名并切换到该分支名)</li>
</ul>
<p>从Git 2.23版本开始，引入了<code>git switch</code> 命令来专门切换分支，这使得切换分支的命令更加清晰和直观。</p>
<ul>
<li><code>git switch 分支名</code></li>
<li><code>git switch -c 分支名</code>   (创建并切换到新分支)</li>
</ul>
</li>
<li><p>合并分支</p>
<ul>
<li>将分支名分支合并到当前分支</li>
<li><code>git merge 分支名</code></li>
</ul>
<p><img src="/../../img/Git/img_4.png" alt="img_4.png"></p>
</li>
<li><p>删除分支 </p>
<ul>
<li><code>git branch -d 分支名</code></li>
</ul>
</li>
</ol>
<h2 id="开发中分支使用原则与流程"><a href="#开发中分支使用原则与流程" class="headerlink" title="开发中分支使用原则与流程"></a>开发中分支使用原则与流程</h2><p>使用分支可以将你的工作与主线分支分离开，避免在修改重大的bug、开发新的功能等情况下影响主线开发。</p>
<ul>
<li><strong><code>master</code></strong> 分支<ul>
<li>主分支，中小项目上线运行时对应的分支</li>
</ul>
</li>
<li><strong><code>develop</code></strong> 分支<ul>
<li>是从master分支创建的分支，在有新需求或者重大修改时可以在此分支上进行改动，在开发完之后合并到master分支</li>
</ul>
</li>
<li><strong><code>feature/xxx</code></strong> 分支 (开发完一般可以删掉)<ul>
<li>是从develop创建的分支，一般是同期并行开发，但不同期上线时创建的分支，分支上的开发任务完成后合并到develop分支</li>
<li>例： <code>feature/add-doc</code>  用于添加文档</li>
</ul>
</li>
<li><strong><code>hotfix/xxx</code></strong> 分支 (开发完一般可以删掉)<ul>
<li>从master分支派生，一般作为线上bug修复使用，修复bug完成后合并到master、test、develop分支</li>
<li>例： <code>hotfix/fix-bug</code>  用于修复bug</li>
</ul>
</li>
<li>还有一些其他分支，如 <strong><code>test</code></strong>(用于代码测试)、<strong><code>pre</code></strong>(预上线分支)等</li>
</ul>
<p><img src="/../../img/Git/img_5.png" alt="img_5.png"></p>
<h2 id="Git远程仓库"><a href="#Git远程仓库" class="headerlink" title="Git远程仓库"></a>Git远程仓库</h2><p>经过前面的学习我们知道了存在两种仓库：即<code>本地仓库</code>和<code>远程仓库</code>。那么如何搭建远程仓库呢？</p>
<p>我们需要借助互联网上提供的代码托管服务，如<code>gitee</code>、<code>github</code>、<code>gitlab</code>，其中前两个我们在日常学习中很常见，第三个一般出现在企业、学校等内部网络搭建git私服，它是一个用于仓库管理系统的开源项目，使用git进行代码托管，并在此基础上搭建web服务。</p>
<h3 id="搭建远程仓库"><a href="#搭建远程仓库" class="headerlink" title="搭建远程仓库"></a>搭建远程仓库</h3><p>给本地仓库添加远程仓库有两种方式，一种是添加https方式，另一种是ssh密钥方式（前者比较简单，这里我们不做赘述，主要学习一下ssh密钥方式）。</p>
<ul>
<li>首先生成ssh密钥<ul>
<li>ssh-keygen -t rsa</li>
<li>不断回车即可（若之前生成过密钥，则自动覆盖）</li>
</ul>
</li>
<li>远程仓库设置密钥<ul>
<li>获取本地密钥</li>
<li>cat ~&#x2F;.ssh&#x2F;id_rsa.pub</li>
<li>验证是否配置成功<ul>
<li>ssh -T <a href="mailto:&#103;&#x69;&#x74;&#x40;&#x67;&#105;&#116;&#x68;&#117;&#98;&#46;&#x63;&#111;&#109;">git@github.com</a> 或者 ssh -T <a href="mailto:&#x67;&#105;&#116;&#64;&#x67;&#105;&#x74;&#x65;&#x65;&#46;&#x63;&#x6f;&#x6d;">git@gitee.com</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="/../../img/Git/img_11.png" alt="img_11.png"><br>出现图示输出则说明配置成功！</p>
<h3 id="远程仓库相关命令"><a href="#远程仓库相关命令" class="headerlink" title="远程仓库相关命令"></a>远程仓库相关命令</h3><ol>
<li>添加远程仓库<ul>
<li><code>git add remote &lt;远端名称&gt; &lt;仓库地址&gt;</code><ul>
<li>例：git remote add origin <a href="mailto:&#x67;&#x69;&#x74;&#64;&#103;&#105;&#x74;&#x68;&#x75;&#x62;&#46;&#x63;&#111;&#109;">git@github.com</a>:zhangjunyi&#x2F;git.git</li>
</ul>
</li>
</ul>
</li>
<li>查看远程仓库<ul>
<li><code>git remote</code></li>
</ul>
</li>
<li>推送到远程仓库<ul>
<li><code>git push [-f] [--set-upstream] [远程仓库] [本地分支]:[远程分支]</code></li>
<li>例：git push origin master<ul>
<li>若本地分支与远程分支名称一致这可只写本地分支 例：git push origin master</li>
<li><code>-f</code> 强制推送 覆盖远程仓库</li>
<li><code>--set-upstream</code> 讲本地分支与远程分支建立联系</li>
</ul>
</li>
<li>如果当前分支和远程分支已经建立联系，则只需执行<code>git push</code>即可</li>
</ul>
</li>
</ol>
<h2 id="Git提交规范"><a href="#Git提交规范" class="headerlink" title="Git提交规范"></a>Git提交规范</h2><p>规范Git提交可以帮助团队协作（新人快速上手）和代码管理。</p>
<h3 id="提交信息-Conventional-Commits"><a href="#提交信息-Conventional-Commits" class="headerlink" title="提交信息(Conventional Commits)"></a>提交信息(Conventional Commits)</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">类型</span>&gt;</span>[可选范围]: 描述</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">正文</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">尾部</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ol>
<li><p>❗️标题(必填)</p>
<ul>
<li>格式：<type>([scope]): <description></li>
<li>示例：feat(user): 新增登录功能</li>
<li>字段说明：<br>- type — 使用明确动词，推荐使用：<br>  - <code>feat</code>: 新功能<br>  - <code>fix</code>: 修复<br>  - <code>style</code>: 样式修改<br>  - <code>refactor</code>: 代码重构<br>  - <code>docs</code>: 文档更改<br>  - <code>test</code>: 测试<br>  - <code>chore</code>: 构建工具变更或辅助脚本变更</li>
</ul>
</li>
<li><p>正文(可选)</p>
<ul>
<li>内容：说明提交描述背景，更改</li>
<li>示例：<ul>
<li>-添加登录表单校验规则</li>
<li>-添加登录方式</li>
</ul>
</li>
</ul>
</li>
<li><p>尾部(可选)</p>
<ul>
<li>关联问题：使用 <code>Closes #123</code> 或 <code>Fixes #456</code> 关联缺陷或需求。</li>
<li>破坏性更改：若引入不兼容改动，需以 <code>BREAKING CHANGE:</code> 开头说明。</li>
</ul>
</li>
</ol>
<p>当然了，我们也可以选择使用工具帮助我们提交，比如<code>Committizen</code>、<code>Husky</code>等，这个可以自行寻找使用方法，这里不多赘述。</p>
<h3 id="提交示例"><a href="#提交示例" class="headerlink" title="提交示例"></a>提交示例</h3><ol>
<li>新增功能 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">feat(user): 添加登录功能</span><br><span class="line"></span><br><span class="line">- 添加登录表单校验规则</span><br><span class="line">- 调试登录api</span><br><span class="line"></span><br><span class="line">close #123</span><br></pre></td></tr></table></figure></li>
<li>修复问题 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fix(home): 修改首页列表加载</span><br><span class="line"></span><br><span class="line">- 分页加载更改为滚动加载</span><br><span class="line"></span><br><span class="line">close #123</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>02- 浏览器运行原理</title>
    <url>/posts/2373884b.html</url>
    <content><![CDATA[<p>从输入路径开始，浏览器是怎样一步步渲染出页面的呢？</p>
<h1 id="网页的解析过程"><a href="#网页的解析过程" class="headerlink" title="网页的解析过程"></a>网页的解析过程</h1><p>输入地址 —&gt; DNS解析 —&gt; 服务器响应 —&gt; 浏览器响应<br>一个网页URL从输入到浏览器中，到显示经历怎样的过程呢？<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image1.png" alt="在这里插入图片描述"></p>
<h2 id="浏览器内核"><a href="#浏览器内核" class="headerlink" title="浏览器内核"></a>浏览器内核</h2><p>常见的浏览器内核：<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image2.png" alt="在这里插入图片描述"><br>我们常说的<code>浏览器内核</code>指的是浏览器的<code>排版引擎</code>，也称之为<code>页面渲染引擎</code>或<code>样板引擎</code>。</p>
<h1 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h1><p>详细内容可看我的另一篇博客：<br><a href="https://blog.csdn.net/2302_79523175/article/details/140614526?spm=1011.2415.3001.5331">浏览器渲染原理</a><br><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image3.png" alt="在这里插入图片描述"></p>
<h2 id="解析html"><a href="#解析html" class="headerlink" title="解析html"></a>解析html</h2><p>因为默认情况下服务器会给浏览器返回index..html文件，所以解析HTML是所有步骤的开始：<br>解析HTML，会构建DOM Tree:<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image4.png" alt="在这里插入图片描述"></p>
<h2 id="生成css规则"><a href="#生成css规则" class="headerlink" title="生成css规则"></a>生成css规则</h2><p>浏览器在解析html时遇到 css 的<code>&lt;link&gt;</code>时会开启另外一个线程对css文件进行下载，这也就不会影响到dom tree的生成；<br>下载完css文件后就会对其进行解析，生成对应的<code>cssom</code>树。<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image5.png" alt="在这里插入图片描述"></p>
<h2 id="构建render-tree"><a href="#构建render-tree" class="headerlink" title="构建render tree"></a>构建render tree</h2><p>当有了<code>DOM Tree</code>和<code>CSSOM Tree</code>两部分之后，就可以结合来生成<code>Render Tree</code>了。<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image6.png" alt="在这里插入图片描述"></p>
<p>注意❗️</p>
<ol>
<li><code>link</code>元素不会阻塞<code>DOM Tree</code>的构建，但是会阻塞<code>Render Tree</code>的构建，因为构建<code>Render Tree</code>需要对应的<code>CSSOM Tree</code>；</li>
<li><strong><code>DOM Tree</code>和<code>Render Tree</code>并不是一一对应的</strong>，有些dom可能设置了<code>display: none;</code>，不会在<code>Render Tree</code>中出现。</li>
</ol>
<h2 id="布局-Layout"><a href="#布局-Layout" class="headerlink" title="布局(Layout)"></a>布局(Layout)</h2><p>布局是确定呈现树中所有节点的宽度、高度和位置信息</p>
<p><code>Render Tree</code>形成之后，就可以对dom的style进行计算：</p>
<ol>
<li><code>em</code>、<code>rem</code>或<code>%</code>等转换成<code>px</code>；</li>
<li>…</li>
</ol>
<h2 id="绘制-Paint"><a href="#绘制-Paint" class="headerlink" title="绘制(Paint)"></a>绘制(Paint)</h2><ul>
<li>在绘制阶段，浏览器将布局阶段计算的每个frame转为屏幕上实际的像素点；</li>
<li>包括将元素的可见部分进行绘制，比如文本、颜色、边框、阴影、替换元素（比如img）<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image7.png" alt="在这里插入图片描述"></li>
</ul>
<h1 id="回流和重绘"><a href="#回流和重绘" class="headerlink" title="回流和重绘"></a>回流和重绘</h1><h2 id="回流reflow"><a href="#回流reflow" class="headerlink" title="回流reflow"></a>回流reflow</h2><h3 id="（1）理解："><a href="#（1）理解：" class="headerlink" title="（1）理解："></a>（1）理解：</h3><ul>
<li>第一次确定节点的位置和大小叫做布局(Layout)；</li>
<li>之后对于节点大小以及位置等的计算叫做回流。</li>
</ul>
<h3 id="（2）出现情况"><a href="#（2）出现情况" class="headerlink" title="（2）出现情况"></a>（2）出现情况</h3><ol>
<li><code>DOM</code>结构发生改变（添加新节点或者移除节点）；</li>
<li>布局改变（修改了width、height、padding等值）；</li>
<li>窗口resize（修改了窗口的尺寸）；</li>
<li>调用<code>getComputedStyle</code>方法获取尺寸、位置信息；</li>
</ol>
<h2 id="重绘repaint"><a href="#重绘repaint" class="headerlink" title="重绘repaint"></a>重绘repaint</h2><h3 id="（1）理解：-1"><a href="#（1）理解：-1" class="headerlink" title="（1）理解："></a>（1）理解：</h3><ul>
<li>第一次渲染内容叫做绘制(Paint)；</li>
<li>之后重新渲染叫做重绘（repaint）。</li>
</ul>
<h3 id="（2）出现情况-1"><a href="#（2）出现情况-1" class="headerlink" title="（2）出现情况"></a>（2）出现情况</h3><ol>
<li>修改背景色、边框颜色、文字颜色、模糊样式等</li>
<li><code>回流</code>一定引起<code>重绘</code>，所以回流是很<strong>消耗性能</strong>的事情。</li>
</ol>
<p><strong>所以在开发中要尽量避免回流</strong>：</p>
<ol>
<li>修改样式时尽量一次性修改<ul>
<li>比如通过<code>cssText</code>修改，通过添加<code>class</code>修改。</li>
</ul>
</li>
<li>尽量避免频繁的操作DOM<ul>
<li>我们可以在一个<code>DocumentFragment</code>(了解即可)或者是父元素中将要操作的DOM操作完成，在一次性的操作。</li>
</ul>
</li>
<li>尽量避免通过<code>getComputedStyle</code>获取尺寸、位置等信息</li>
<li>对某些元素使用<code>position</code>的<code>absolute</code>或<code>fixed</code><ul>
<li>这种操作并不是不会引起回流，而是相对来说开销较小，不会对其他元素造成影响。</li>
</ul>
</li>
</ol>
<h1 id="特殊解析composite合成-和性能优化"><a href="#特殊解析composite合成-和性能优化" class="headerlink" title="特殊解析composite合成 和性能优化"></a>特殊解析composite合成 和性能优化</h1><p>绘制的过程，浏览器会将布局后的元素绘制到多个合成图层中（这是浏览器的一种优化手段）；</p>
<ul>
<li>默认情况下，标准流的元素会被绘制到同一个图层中；</li>
<li>而某些特殊的属性，会单独创建一个新的合成层，并且新的图层可以使用<code>GPU</code>加速绘制（每个合成层都是单独进行渲染）</li>
</ul>
<p><strong>哪些属性可以形成新的合成层呢</strong>？下面是常见的一下属性：</p>
<ul>
<li>3D transforms</li>
<li><code>video</code>、<code>canvas</code>、<code>iframe</code></li>
<li><code>opacity</code>动画转换</li>
<li><code>position: fixed</code></li>
<li><code>will-cahnge</code>：一个实验性的属性，提前告诉浏览器可能会发生哪些变化</li>
<li><code>animation</code>或<code>transition</code>设置了<code>opacity</code>、<code>transform</code></li>
</ul>
<p>注❗️：<br>分层确实可以提高性能，但是它以内存管理为代价，因此不应作为web性能优化策略的一部分过度使用！</p>
<h1 id="defer和async属性"><a href="#defer和async属性" class="headerlink" title="defer和async属性"></a>defer和async属性</h1><p>首先来了解一下 <strong><code>script</code>和页面解析的关系</strong> !</p>
<p>前面我们已经知道了，浏览器在解析html时遇到<code>&lt;link&gt;</code>不会影响<code>DOM Tree</code>的构建，那遇到<code>&lt;script&gt;</code>呢？会影响吗？<br>答案是：<strong>会的！</strong></p>
<ul>
<li>浏览器在遇到<code>&lt;script&gt;</code>时会先停止对<code>DOM Tree</code>构建，转而去下载、执行js脚本；</li>
<li>只有js脚本执行完毕后，<code>DOM Tree</code>才能继续进行构建；</li>
</ul>
<p>那这是为什么呢？</p>
<ul>
<li>因为js文件中可能存在对<code>DOM</code>的操作；</li>
<li>若先构建<code>DOM Tree</code>，再执行js脚本，可能会造成严重的回流和重绘，影响页面性能。</li>
</ul>
<p>但是这也会带来新的问题，特别是现在主流框架：</p>
<ul>
<li>目前主要流行的<code>Vue</code>、<code>React</code>，脚本往往比html页面更”重”，处理时间更长，</li>
<li>也就是在js脚本执行结束前，页面可能出现空白</li>
</ul>
<p>（有些浏览器可能对此做了优化，也就是在js脚本执行接受之前，先将已经构建的<code>DOM Tree</code>进行展示）<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image8.png" alt="在这里插入图片描述"></p>
<p>为了解决这个问题，<code>&lt;script&gt;</code>给我们提供了两个属性：<code>defer</code>和<code>async</code></p>
<h2 id="4-1-defer"><a href="#4-1-defer" class="headerlink" title="4.1 defer"></a>4.1 defer</h2><ul>
<li>defer会告诉浏览器不要等待脚本的下载，继续执行<code>DOM Tree</code>的构建</li>
<li>脚本的下载有浏览器完成，不会影响<code>DOM Tree</code>的构建；</li>
<li>若脚本先下载完，那它会等待<code>DOM Tree</code>构建完成，在<code>DOMContentLoaded</code>事件执行前执行defer中的代码</li>
</ul>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/02-browser/image9.png" alt="在这里插入图片描述"><br>总结：</p>
<ol>
<li><code>defer</code>不会影响<code>DOM Tree</code>的构建；</li>
<li>在<code>defer</code>中<code>DOM Tree</code>已经构建完成，可进行对dom的操作；</li>
<li><code>defer</code>总是在<code>DOMContentLoaded</code>时间发出前执行；</li>
<li>另外，有多个<code>defer</code>会按照编写顺序执行；</li>
<li>从某种角度来说，<code>defer</code>会提高页面性能，并且推荐放在<code>&lt;head&gt;</code>中（提前下载js脚本）；</li>
<li>注意：<code>defer</code>仅适用于外部脚本，对于<code>&lt;script&gt;</code>默认内容会被忽略。</li>
</ol>
<h2 id="4-2-async"><a href="#4-2-async" class="headerlink" title="4.2 async"></a>4.2 async</h2><ul>
<li><code>async</code>和<code>defer</code>相似，都能够让脚本不堵塞页面；</li>
<li><code>async</code>是完全独立于浏览器的：<ul>
<li>浏览器页面不会因为<code>script</code>脚本而暂停<code>DOM Tree</code>的构建；</li>
<li><code>async</code>脚本不能保证顺序执行脚本，它独立下载，独立运行，不会等待其他脚本；</li>
<li><code>async</code>不一定在<code>DOMContentLoaded</code>时间执行前执行</li>
</ul>
</li>
</ul>
<p><strong>总结：</strong></p>
<ol>
<li><code>defer</code>通常需要在文档解析后操作<code>DOM</code>的<code>javascript</code>代码，并且对多个<code>script</code>文件有顺序要求；</li>
<li><code>async</code>通常用于独立的脚本，对其他脚本，甚至<code>DOM</code>没有依赖的。</li>
</ol>
<p>注：整个JS高级专栏依托于coderwhy老师的课程，相关图片、代码均来自于其课程。</p>
]]></content>
      <categories>
        <category>js高级</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title>03-javascript的运行原理</title>
    <url>/posts/4bc49eeb.html</url>
    <content><![CDATA[<p>上篇博客了解了一下浏览器的运行原理，那javascript的运行原理又是怎么样的呢？</p>
<h1 id="V8引擎"><a href="#V8引擎" class="headerlink" title="V8引擎"></a>V8引擎</h1><p>先来了解一下V8引擎:</p>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image1.png" alt="在这里插入图片描述"></p>
<p>简单来说，V8引擎就是在做<strong>将<code>javascript</code>代码转换成机器语言</strong>，从而被cpu识别继而运行的工作。</p>
<h2 id="执行原理与架构（了解）"><a href="#执行原理与架构（了解）" class="headerlink" title="执行原理与架构（了解）"></a>执行原理与架构（了解）</h2><p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image2.png" alt="在这里插入图片描述"><br>V8引擎本身的源码非常复杂，大概有超过100w行C++代码，通过了解它的架构，我们可以知道它是如何对)vaScript执行的：</p>
<ul>
<li><p><code>Parse</code>：将<code>javascript</code>代码转换成<code>AST抽象语法树</code>，因为解释器并不直接认识js代码；</p>
<ul>
<li>如果函数没有被调用，那么就不会被转成<code>AST</code></li>
</ul>
</li>
<li><p><code>lgnition</code>：是一个解释器，会将<code>AST</code>转换成字节码；</p>
<ul>
<li>同时会收集<code>TurboFan</code>需要的类型信息（比如函数参数的类型信息，有了类型才能进行真实的运算）</li>
<li>如果函数只执行一次，那么将直接解释执行字节码</li>
</ul>
</li>
<li><p><code>TurboFan</code>：是一个编译器，可以将<code>AST</code>转换成CPU直接能运行的机器码；</p>
<ul>
<li>如果一个函数被多次调用，那么将会被标记为<code>热点函数</code>，那么就会经过<code>TurboFan</code>编译成优化的机器码，提高代码的执行性能；</li>
<li>但是，<strong>机器码实际上也会被还原成字节码</strong>，这是因为如果后续执行过程中类型发生了变化，之前优化的机器码并不能正确的运算，就会逆向的转成字节码</li>
</ul>
</li>
</ul>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image3.png" alt="在这里插入图片描述"></p>
<h1 id="javascript-执行过程"><a href="#javascript-执行过程" class="headerlink" title="javascript 执行过程"></a>javascript 执行过程</h1><p>假设现在有段这样的代码，它应该是怎样执行的呢？<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image4.png" alt="在这里插入图片描述"></p>
<p>我们先来了解一下相关的基础知识！</p>
<h2 id="初始化全局对象"><a href="#初始化全局对象" class="headerlink" title="初始化全局对象"></a>初始化全局对象</h2><ul>
<li>首先，<code>js</code> 在执行代码前，会创建一个全局对象：<code>Global Object</code><ul>
<li>该对象 所有的作用域都可以访问；</li>
<li>里面还会包含<code>Date</code>、<code>Array</code>、<code>Number</code>、<code>setTimeout</code>、<code>setInterval</code>等；</li>
<li>其中还有一个属性指向<code>window</code></li>
</ul>
</li>
</ul>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image5.png" alt="在这里插入图片描述"></p>
<h2 id="执行上下文栈"><a href="#执行上下文栈" class="headerlink" title="执行上下文栈"></a>执行上下文栈</h2><p>js 引擎内部有一个<code>执行上下文栈</code>（Excution Context Stack，简称ECS），是用于执行代码的调用栈。</p>
<ul>
<li><p>那么现在要执行的是谁呢？是全局的代码块：</p>
<ul>
<li>全局的代码块在执行前会创建一个<code>Global Excution Context（GEC）</code>；</li>
<li><code>GEC</code>会被放到<code>ECS</code>中执行</li>
</ul>
</li>
<li><p><code>GEC</code>被放到<code>ECS</code>中包含两部分内容：</p>
<ul>
<li>第一部分：在代码执行前，在<code>parser</code>转成<code>AST</code>的过程中，会将全局定义的变量、函数等加入到<code>Global Object</code>中，但并不会赋值；（这个过程也叫做变量的作用域提升）</li>
<li>在代码执行中，对变量赋值，或者执行其他的函数；</li>
</ul>
</li>
</ul>
<h1 id="全局代码的执行"><a href="#全局代码的执行" class="headerlink" title="全局代码的执行"></a>全局代码的执行</h1><p>先来认识一下<code>VO对象</code>：</p>
<ul>
<li>每个执行上下文都会关联一个VO（Variable Object，变量对象），变量和函数声明会被添加到这个VO对象中；</li>
<li>当全局代码被执行的时候，VO就是GO对象了。</li>
</ul>
<p>❗️❗️❗️问题来了！<strong>全局代码如何被执行呢？</strong></p>
<p><strong>执行前：</strong><br><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image6.png" alt="在这里插入图片描述"><br><strong>执行后：</strong><br><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image7.png" alt="在这里插入图片描述"><br>现在更改代码为：<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image8.png" alt="在这里插入图片描述"></p>
<p>那就又有一个问题：<strong>函数代码如何执行呢？</strong></p>
<h1 id="函数代码的执行"><a href="#函数代码的执行" class="headerlink" title="函数代码的执行"></a>函数代码的执行</h1><ul>
<li>执行代码遇到函数体时，就会根据函数体创建一个函数体上下文（Functional Excution Context），并且压入到ECS中；</li>
<li>当进入函数体执行代码时，就会创建一个<code>AO（Activation Obejct）</code>；</li>
<li>这个<code>AO</code>会使用<code>arguments</code>作为初始化，并且初始值是传入的参数；</li>
<li>这个<code>AO</code>对象会作为该函数体的执行上下文的<code>VO</code>来存放变量的初始化</li>
</ul>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image9.png" alt="在这里插入图片描述"></p>
<p>执行函数上下文之后：</p>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image10.png" alt="在这里插入图片描述"></p>
<p>之后，函数执行上下文将会被压出栈外：</p>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image11.png" alt="在这里插入图片描述"></p>
<p>❗️在函数作用域中可能遇到这样的情况：</p>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image12.png" alt="在这里插入图片描述"></p>
<blockquote>
<p><code>message</code>变量的声明存在于全局作用域，但在局部作用域进行了调用，<strong>那局部作用域又是怎么找到全距作用与中的变量呢？</strong></p>
</blockquote>
<p>这就涉及到了<code>javascript</code>的作用域和作用链！</p>
<h1 id="作用域和作用链"><a href="#作用域和作用链" class="headerlink" title="作用域和作用链"></a>作用域和作用链</h1><p><img src="/../../img/js%E9%AB%98%E7%BA%A7/03-oringinal-run-js/image13.png" alt="在这里插入图片描述"></p>
<p>上面说到，但我们进入一个执行上下文时，执行上下文会关联一个VO对象，其实，同时它也会关联一个 <strong><code>作用域链（Scope Chain）</code></strong>。</p>
<ul>
<li>作用域链是一个对象列表，用于表示变量标识符的求值；</li>
<li>当进入一个执行上下文时，这个作用域链就会被创建，并且根据代码类型，添加一系列的对象</li>
</ul>
]]></content>
      <categories>
        <category>js高级</category>
      </categories>
      <tags>
        <tag>javascript运行原理</tag>
      </tags>
  </entry>
  <entry>
    <title>04-闭包</title>
    <url>/posts/2f741396.html</url>
    <content><![CDATA[<h1 id="javascript-内存管理"><a href="#javascript-内存管理" class="headerlink" title="javascript 内存管理"></a>javascript 内存管理</h1><blockquote>
<p>认识内存管理</p>
</blockquote>
<p>不管什么样的编程语言，<strong>在代码执行过程中都需要进行内存分配</strong>，不同的是有些编程语言需要我们自己手动进行内存配置，有些则会自动帮我们进行内存分配。</p>
<p>不管什么样的内存分配机制，<strong>内存的分配都会进入如下周期</strong>：</p>
<ol>
<li>申请分配内存</li>
<li>使用分配的内存</li>
<li>不需要使用时释放内存</li>
</ol>
<p>不同的语言会对第一步和第三步进行不同的处理：</p>
<ul>
<li>手动管理内存：比如<code>C</code>、<code>C++</code>，包括早期的<code>OC</code>，都是需要手动的进行内存的申请和释放（<code>malloc和free函数</code>）；</li>
<li>自动管理内存：比如<code>java</code>、<code>javascript</code>、<code>Python</code>、<code>Swift</code>、<code>Dart</code>等，这些语言都有帮我们自动进行内存管理。</li>
</ul>
<p>也就是说，我们所使用的<code>javascript</code>会自动的对原始值、对象、函数等进行内存管理，我们并不需要进行多余的操作。</p>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/04-closure/img1.png" alt="img.png"></p>
<h1 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h1><h1 id="闭包的概念理解"><a href="#闭包的概念理解" class="headerlink" title="闭包的概念理解"></a>闭包的概念理解</h1><h1 id="闭包的形成过程"><a href="#闭包的形成过程" class="headerlink" title="闭包的形成过程"></a>闭包的形成过程</h1><h1 id="闭包的内存泄漏"><a href="#闭包的内存泄漏" class="headerlink" title="闭包的内存泄漏"></a>闭包的内存泄漏</h1>]]></content>
      <categories>
        <category>js高级</category>
      </categories>
      <tags>
        <tag>闭包</tag>
      </tags>
  </entry>
  <entry>
    <title>01- this的指向规则</title>
    <url>/posts/d8cbe511.html</url>
    <content><![CDATA[<p><code>this</code> 到底指向谁? 箭头函数中的<code>this</code>还能使用吗? 如果能使用又要怎么使用呢? 与普通函数的<code>this</code>指向一致吗?</p>
<h2 id="this到底指向谁？"><a href="#this到底指向谁？" class="headerlink" title="this到底指向谁？"></a><code>this</code>到底指向谁？</h2><p>首先，定义一个函数：</p>
<p>三种不同的调用方式，this的指向也会不同！</p>
<ol>
<li><p>直接调用</p>
<blockquote>
<p>foo()  &#x2F;&#x2F; window{}</p>
</blockquote>
</li>
<li><p>通过对象调用</p>
 <figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var obj = &#123; name: &#x27;name&#x27; &#125;</span><br><span class="line">obj.foo = foo</span><br><span class="line">obj.foo(); // Object&#123;&#125;     (obj这个对象)</span><br></pre></td></tr></table></figure>
</li>
<li><p>call&#x2F;apply&#x2F;bind</p>
<blockquote>
<p>foo.apply(“abc”) &#x2F;&#x2F;  String {‘abc’}</p>
</blockquote>
</li>
</ol>
<p><strong>结论：</strong></p>
<ol>
<li>函数在调用时，js会<strong>默认给this绑定一个值</strong>；</li>
<li>this的绑定跟它**定义的位置（编写的位置）**没有关系；</li>
<li>this的绑定与调用方式以及调用的位置有关；</li>
<li>this是在运行时被绑定的。</li>
</ol>
<h2 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a><code>this</code>的绑定规则</h2><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><ul>
<li>普通函数被独立调用</li>
</ul>
<blockquote>
<p>foo()   &#x2F;&#x2F; window{}</p>
</blockquote>
<ul>
<li>函数定义在对象中，但是独立被调用</li>
</ul>
<blockquote>
<p>var bar &#x3D; obj.foo<br>bar()  &#x2F;&#x2F; window{}</p>
</blockquote>
<ul>
<li><font style="color:#DF2A3F;">严格模式</font>下，独立调用的函数中的<code>this</code>指向<code>undefined</code></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"><span class="meta"></span></span></span><br><span class="line"><span class="meta"><span class="language-javascript">	&quot;use strict&quot;</span></span></span><br><span class="line"><span class="language-javascript">	...</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>高阶函数</li>
</ul>
<blockquote>
<p>function test(fn) {<br>    fn()<br>}</p>
<p>test(obj.foo) &#x2F;&#x2F; window{}</p>
</blockquote>
<p>即独立调用函数时(非严格模式下)<code>this</code>指向<code>window</code>!</p>
<h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><blockquote>
<p>一般是通过<strong>对象</strong>来发起调用。</p>
</blockquote>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/01-this-img/image1.png"></p>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/01-this-img/image2.png"></p>
<h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo.<span class="title function_">call</span>(obj)</span><br><span class="line">foo.<span class="title function_">apply</span>(obj) <span class="comment">// foo &#123;name:&#x27;name&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>这两种形式的显示绑定区别不大，不会像隐式绑定那样在obj上面添加foo:foo，但是foo的this就指向了obj；</li>
<li>另外，这种形式一般将this绑定在对象身上，如果foo.call(‘abc’)，那么也会默认将’abc’创建为对应的包装类型，这里也就是<code>String</code>对象;</li>
<li>如果是绑定在了<code>undefined</code>这种没有对应包装类型的对象身上，那么this就会默认指向<code>window</code></li>
</ul>
<h4 id="call-apply函数说明"><a href="#call-apply函数说明" class="headerlink" title="call &#x2F; apply函数说明"></a>call &#x2F; apply函数说明</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;参数:&#x27;</span>, name, age); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>作用：都可以调取函数并绑定this，传递参数方式不同</p>
<ul>
<li><code>apply(obj,[argumentsArray])</code></li>
</ul>
<p><code>obj</code>是指this指向的对象；</p>
<p><code>argumentsArray</code>是指函数的参数，必须要放在<strong>数组</strong>中进行传递；</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// apply</span></span><br><span class="line">test.<span class="title function_">apply</span>(<span class="string">&#x27;apply&#x27;</span>, [<span class="string">&#x27;chenber&#x27;</span>, <span class="number">18</span>]) <span class="comment">// 参数: chenber 18</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>&lt;font style=&quot;color:#DF2A3F;&quot;&gt;call(obj,arg1,arg2,...)&lt;/font&gt;</code></li>
</ul>
<p><code>obj</code>是指this指向的对象；</p>
<p><code>arg1,arg2,...</code>是指函数的参数列表。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// call</span></span><br><span class="line">test.<span class="title function_">call</span>(<span class="string">&#x27;call&#x27;</span>, <span class="string">&#x27;chender&#x27;</span>, <span class="number">18</span>) <span class="comment">// 参数: chender 18</span></span><br></pre></td></tr></table></figure>

<h4 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bind</span></span><br><span class="line"><span class="keyword">var</span> bar = test.<span class="title function_">bind</span>(<span class="string">&#x27;bind&#x27;</span>)</span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// 参数:this,String&#123;&#x27;bind&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = test.<span class="title function_">call</span>(<span class="string">&#x27;call&#x27;</span>, <span class="string">&#x27;chender&#x27;</span>, <span class="number">18</span>) <span class="comment">// 参数: chender 18</span></span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>

<p><code>bind</code>是<code>绑定（怪异）函数</code>，是返回绑定过对象的函数，那么在执行的时候this只会指向绑定好的对象；</p>
<p>而<code>call</code>和<code>apply</code>都是直接执行函数，没有返回值 。</p>
<ul>
<li>bind()的其他参数</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> bar = test.<span class="title function_">call</span>(<span class="string">&#x27;call&#x27;</span>, <span class="string">&#x27;chender&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// 参数: chender 18</span></span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">// 参数: chender 18    （参数一开始就指定好了，修改不了）</span></span><br></pre></td></tr></table></figure>

<p>❗️❗️❗️此时，会不会有疑问？（bar()函数单独调用，this不应该指向window吗？）</p>
<p>这里就涉及到了<strong>this绑定的优先级</strong>了！</p>
<ol>
<li><p>默认绑定优先级最低</p>
</li>
<li><p>显式绑定 &gt; 隐式绑定</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;chenber&#x27;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="attr">test</span>: test</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="property">test</span>.<span class="title function_">apply</span>(<span class="string">&#x27;apply&#x27;</span>, [<span class="string">&#x27;1&#x27;</span>, <span class="number">19</span>]) </span><br><span class="line"><span class="comment">// this [String: &#x27;apply&#x27;]</span></span><br><span class="line"><span class="comment">// 参数: 1 19</span></span><br><span class="line"><span class="keyword">var</span> test1 = obj.<span class="property">test</span>.<span class="title function_">bind</span>(<span class="string">&#x27;bind&#x27;</span>, <span class="string">&#x27;chenber&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="title function_">test1</span>()</span><br><span class="line"><span class="comment">// this [String: &#x27;bind&#x27;]</span></span><br><span class="line"><span class="comment">// 参数: chenber 18</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>new 绑定 &gt; 隐式绑定</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;chenber&#x27;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo:&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo:&#x27;</span>, <span class="variable language_">this</span> === obj);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">foo</span>()</span><br><span class="line"><span class="comment">// foo: foo &#123;&#125;</span></span><br><span class="line"><span class="comment">// foo: false</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>new &gt; 显式(bind)</p>
<p>❗️<code>new</code>和<code>apply</code> &#x2F; <code>call</code>不可以一起使用，所以没有可比性</p>
<p><code>new</code>和<code>bind</code>可以一起使用</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;test&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> testFN = test.<span class="title function_">bind</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">testFN</span>() <span class="comment">// test&#123;&#125;</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>使用new关键字来调用函数是，会执行如下的操作：</p>
<ul>
<li>创建一个全新的对象；</li>
<li>这个新对象会被执行prototype连接：</li>
<li>这个新对象会绑定到函数调用的this上（this的绑定在这个步骤完成）；</li>
<li>如果函数没有返回其他对象，表达式会返回这个新对象：</li>
</ul>
<p><strong>总结(优先级从高到低)：</strong></p>
<ol>
<li>new</li>
<li>bind </li>
<li>apply &#x2F; call</li>
<li>隐式</li>
<li>默认绑定</li>
</ol>
<h2 id="内置函数的调用绑定"><a href="#内置函数的调用绑定" class="headerlink" title="内置函数的调用绑定"></a>内置函数的调用绑定</h2><p>内置函数的this指向需要<code>根据一些经验</code>获取</p>
<ol>
<li><p>setTimeOut()</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setTimeOut</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this&#x27;</span>, <span class="variable language_">this</span>) <span class="comment">//window</span></span><br><span class="line">&#125;,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>按钮的点击监听</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="variable language_">document</span>.<span class="title function_">querySelector</span>(<span class="string">&#x27;button&#x27;</span>)</span><br><span class="line">btn.<span class="property">onclick</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;btn&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// &lt;button&gt;点击&lt;/button&gt;</span></span><br><span class="line">&#125;</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;btn&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// &lt;button&gt;点击&lt;/button&gt;</span></span><br><span class="line">&#125;)</span><br><span class="line">btn.<span class="title function_">addEventListener</span>(<span class="string">&quot;click&quot;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;btn&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>forEach</p>
<p> forEach(function(){}, {})</p>
</li>
</ol>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/01-this-img/image3.png"></p>
<p>forEach的两个参数：</p>
<ol>
<li>回调函数</li>
<li>回调函数的this绑定对象</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> names = [<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>, <span class="string">&quot;abc&quot;</span>]</span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;forEach&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">names.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;forEach&#x27;</span>, <span class="variable language_">this</span>); <span class="comment">// String &#123;&#x27;abc&#x27;&#125;</span></span><br><span class="line">&#125;, <span class="string">&quot;cba&quot;</span>)</span><br></pre></td></tr></table></figure>
<h2 id="this-绑定之外的规则"><a href="#this-绑定之外的规则" class="headerlink" title="this 绑定之外的规则"></a><code>this</code> 绑定之外的规则</h2><ol>
<li><p>如果在使用显式绑定时传入<code>null</code>或者<code>undefined</code>，那么就会使用默认绑定规则</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo.<span class="title function_">apply</span>(<span class="literal">null</span>) <span class="comment">// window</span></span><br><span class="line">foo.<span class="title function_">apply</span>(<span class="literal">undefined</span>) <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<p> 严格模式差异：在严格模式下，绑定null&#x2F;undefined时会直接使用传入值，this会指向null或undefined本身。</p>
</li>
<li><p>间接函数引用（知道就行，一般不会出现）</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj2 = &#123;&#125;;</span><br><span class="line">    (obj2.<span class="property">foo</span> = obj.<span class="property">foo</span>)() <span class="comment">// window</span></span><br></pre></td></tr></table></figure></li>
<li><p>箭头函数(补充)<br>箭头函数是 <code>es6</code> 新增的一种函数的声明方法。</p>
</li>
</ol>
<ul>
<li>完整写法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = (<span class="params">name,age</span>)=&gt;&#123;</span><br><span class="line">	<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;=&gt;&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>❗️注:</p>
<pre><code>- 箭头函数不会绑定`this` 和 `arguments`(有新的属性进行代替)属性；
- 箭头函数不能作为构造函数来使用（会抛出错误）
</code></pre>
<ul>
<li>箭头函数的简写<ul>
<li>只有一个参数时 可省略()<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/01-this-img/image4.png"></li>
<li>函数体只有一行语句时，可省略{}，但是不能带return 关键字<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/01-this-img/image5.png"></li>
<li>如果执行体只有返回一个对象，那么需要给这个对象加上()<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/01-this-img/image6.png"></li>
</ul>
</li>
</ul>
<h2 id="箭头函数中的-this-使用"><a href="#箭头函数中的-this-使用" class="headerlink" title="箭头函数中的 this 使用"></a>箭头函数中的 <code>this</code> 使用</h2><p> <strong>箭头函数的作用域没有 <code>this</code> ！</strong><br> 但是箭头函数中<code>this</code>会向寻找上层作用域中的<code>this</code>，直至找到全局this-&gt;<code>window</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">test</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>() <span class="comment">// window</span></span><br><span class="line"><span class="keyword">var</span> test1 = test.<span class="title function_">bind</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="title function_">test1</span>() <span class="comment">// window</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">	<span class="attr">name</span>: <span class="string">&#x27;chenber&#x27;</span>,</span><br><span class="line">	<span class="attr">foo</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;this&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br><span class="line">obj.<span class="title function_">foo</span>() <span class="comment">// window</span></span><br><span class="line"><span class="keyword">const</span> test2 = obj.<span class="property">foo</span>.<span class="title function_">bind</span>(<span class="string">&#x27;abc&#x27;</span>)</span><br><span class="line"><span class="title function_">test2</span>() <span class="comment">// window</span></span><br></pre></td></tr></table></figure>
<p>应用实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 模拟网络请求函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">url, callbackFn</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> results = &#123;<span class="attr">code</span>: <span class="number">200</span>, <span class="attr">msg</span>: <span class="string">&#x27;成功&#x27;</span>, <span class="attr">data</span>: <span class="literal">null</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">callbackFn</span>(results)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将获取的数据传输给obj的results</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">    <span class="attr">results</span>: &#123;&#125;,</span><br><span class="line">    <span class="comment">// 之前的写法：</span></span><br><span class="line">    <span class="comment">// getData: function () &#123;</span></span><br><span class="line">    <span class="comment">//   var _this = this</span></span><br><span class="line">    <span class="comment">//   request(&#x27;/test&#x27;, function (res) &#123;</span></span><br><span class="line">    <span class="comment">//     _this.results = res</span></span><br><span class="line">    <span class="comment">//   &#125;)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// 使用箭头函数:</span></span><br><span class="line">    <span class="attr">getData</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="title function_">request</span>(<span class="string">&#x27;/test&#x27;</span>, <span class="function">(<span class="params">res</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">results</span> = res</span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.<span class="title function_">getData</span>()</span><br></pre></td></tr></table></figure>
<h2 id="1-6-相关面试题"><a href="#1-6-相关面试题" class="headerlink" title="1.6 相关面试题"></a>1.6 相关面试题</h2><ol>
<li>面试题一</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 面试题一</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;person&#x27;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sss = person.<span class="property">sayName</span>;</span><br><span class="line">  <span class="title function_">sss</span>(); <span class="comment">// 默认绑定  输出：window</span></span><br><span class="line"></span><br><span class="line">  person.<span class="title function_">sayName</span>(); <span class="comment">// 隐式绑定  输出：person</span></span><br><span class="line">  (person.<span class="property">sayName</span>)();  <span class="comment">// 隐式绑定  输出：person  // 此处的;不能省略，因为下面是间接函数引用</span></span><br><span class="line">  (b = person.<span class="property">sayName</span>)() <span class="comment">// 默认绑定  输出：window     此处为间接函数引用，相当于独立函数调用，即this指向window </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>面试题二</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 面试题二</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">var</span> person1 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;person1&#x27;</span>,</span><br><span class="line">  <span class="attr">foo1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo2</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>),</span><br><span class="line">  <span class="attr">foo3</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo4</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;person2&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo1</span>(); <span class="comment">// 隐式绑定  输出：person1</span></span><br><span class="line">person1.<span class="property">foo1</span>.<span class="title function_">call</span>(person2); <span class="comment">// 显示绑定   输出：person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo2</span>(); <span class="comment">// 默认绑定  输出：window  </span></span><br><span class="line">person1.<span class="property">foo2</span>.<span class="title function_">call</span>(person2); <span class="comment">// 显示绑定  this-&gt;上层作用域  输出：window</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 上层作用域指的是函数定义时的作用域，而不是函数运行时的作用域   </span></span><br><span class="line"><span class="comment">// 所以下面这几种情况要注意区分</span></span><br><span class="line">person1.<span class="title function_">foo3</span>()(); <span class="comment">// 默认绑定  输出：window </span></span><br><span class="line">person1.<span class="property">foo3</span>.<span class="title function_">call</span>(person2)(); <span class="comment">// 显示绑定  输出：window</span></span><br><span class="line">person1.<span class="title function_">foo3</span>().<span class="title function_">call</span>(person2); <span class="comment">// 显示绑定  输出：person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo4</span>()(); <span class="comment">// 间接函数引用  输出：person1</span></span><br><span class="line">person1.<span class="property">foo4</span>.<span class="title function_">call</span>(person2)(); <span class="comment">// 间接函数引用  输出：person2</span></span><br><span class="line">person1.<span class="title function_">foo4</span>().<span class="title function_">call</span>(person2); <span class="comment">// 显式绑定  输出：person1</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>面试题三</li>
</ol>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/01-this-img/image7.png" alt="在这里插入图片描述"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 面试题三</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo1</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo2</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo3</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">foo4</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo1</span>(); <span class="comment">// 隐式绑定  输出：person1</span></span><br><span class="line">person1.<span class="property">foo1</span>.<span class="title function_">call</span>(person2); <span class="comment">// 显示绑定  输出：person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo2</span>(); <span class="comment">// 上层作用域查找  输出：person1  </span></span><br><span class="line">person1.<span class="property">foo2</span>.<span class="title function_">call</span>(person2); <span class="comment">// 显示绑定  this-&gt;上层作用域  输出：person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo3</span>()(); <span class="comment">// 默认绑定  输出：window </span></span><br><span class="line">person1.<span class="property">foo3</span>.<span class="title function_">call</span>(person2)(); <span class="comment">// 显式绑定  输出：window</span></span><br><span class="line">person1.<span class="title function_">foo3</span>().<span class="title function_">call</span>(person2); <span class="comment">// 显式绑定  输出：person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="title function_">foo4</span>()(); <span class="comment">// 隐式绑定 上层作用域查找  输出：person1</span></span><br><span class="line">person1.<span class="property">foo4</span>.<span class="title function_">call</span>(person2)(); <span class="comment">// 显式绑定  上层作用域查找  输出：person2</span></span><br><span class="line">person1.<span class="title function_">foo4</span>().<span class="title function_">call</span>(person2); <span class="comment">// 显式绑定  上层作用域查找  输出：person1</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>面试题四</li>
</ol>
<p><img src="/../../img/js%E9%AB%98%E7%BA%A7/01-this-img/image8.png" alt="在这里插入图片描述"></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 面试题四</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">&#x27;window&#x27;</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">obj</span> = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">foo1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="attr">foo2</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person1&#x27;</span>)</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;person2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo1</span>()()<span class="comment">// 隐式绑定 window</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="property">foo1</span>.<span class="title function_">call</span>(person2)() <span class="comment">// 显式绑定 window</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo1</span>().<span class="title function_">call</span>(person2) <span class="comment">//  显式绑定 person2</span></span><br><span class="line"></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo2</span>()() <span class="comment">// 隐式绑定 obj</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="property">foo2</span>.<span class="title function_">call</span>(person2)() <span class="comment">// 显式绑定 person2</span></span><br><span class="line">person1.<span class="property">obj</span>.<span class="title function_">foo2</span>().<span class="title function_">call</span>(person2) <span class="comment">// 显式绑定 obj</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>js高级</category>
      </categories>
      <tags>
        <tag>this指向</tag>
      </tags>
  </entry>
  <entry>
    <title>08-手写apply/call/bind</title>
    <url>/posts/5be1151a.html</url>
    <content><![CDATA[<p>手撕apply&#x2F;call&#x2F;bind</p>
<ul>
<li>apply()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myApply</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否是函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;type error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断this要绑定的对象是否为空</span></span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  context.<span class="property">fn</span> = <span class="variable language_">this</span></span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>, args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line">  context.<span class="title function_">fn</span>(...args)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ul>
<li>call()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myCall</span> = <span class="keyword">function</span> (<span class="params">context</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断调用对象是否是函数</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&#x27;type error&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 判断this要绑定的对象是否为空</span></span><br><span class="line">  context = context || <span class="variable language_">window</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// context.fn = this   </span></span><br><span class="line">  <span class="comment">// 如果不想fn()被展示出来就使用Object.defineProperty()</span></span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(context, <span class="string">&#x27;fn&#x27;</span>, &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="variable language_">this</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">true</span></span><br><span class="line">    &#125;)</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">let</span> result = <span class="literal">null</span>, args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  此处fn的调用方式与apply()不同，这个更适合call()风格</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">arguments</span>[<span class="number">1</span>]) &#123;</span><br><span class="line">    context.<span class="title function_">fn</span>(...args)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    context.<span class="title function_">fn</span>()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">delete</span> context.<span class="property">fn</span></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>bind()</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">myBind</span> = <span class="keyword">function</span>(<span class="params">context</span>) &#123;</span><br><span class="line">    <span class="comment">// 判断调用对象是否为函数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="variable language_">this</span> !== <span class="string">&quot;function&quot;</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取参数</span></span><br><span class="line">    <span class="keyword">var</span> args = [...<span class="variable language_">arguments</span>].<span class="title function_">slice</span>(<span class="number">1</span>),</span><br><span class="line">        fn = <span class="variable language_">this</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> <span class="title function_">Fn</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="comment">// 根据调用方式，传入不同绑定值</span></span><br><span class="line">        <span class="keyword">return</span> fn.<span class="title function_">apply</span>(</span><br><span class="line">            <span class="variable language_">this</span> <span class="keyword">instanceof</span> <span class="title class_">Fn</span> ? <span class="variable language_">this</span> : context,</span><br><span class="line">            args.<span class="title function_">concat</span>(...<span class="variable language_">arguments</span>)</span><br><span class="line">        );</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>












]]></content>
      <categories>
        <category>js高级</category>
      </categories>
      <tags>
        <tag>apply/call/bind</tag>
      </tags>
  </entry>
  <entry>
    <title>07-原型和原型链</title>
    <url>/posts/e3799824.html</url>
    <content><![CDATA[<p>认识一下原型和原型链。</p>
<h1 id="1-认识原型"><a href="#1-认识原型" class="headerlink" title="1. 认识原型"></a>1. 认识原型</h1><p><strong>原型是什么？怎样获取？</strong></p>
<h2 id="1-1-ES5-–-对象的原型"><a href="#1-1-ES5-–-对象的原型" class="headerlink" title="1.1 ES5 – 对象的原型"></a>1.1 ES5 – <strong>对象</strong>的原型</h2><p>每个对象身上都有一个[[prototype]]内置属性，这个特殊的对象可以指向另外一个对象。</p>
<ul>
<li>当我们通过引用对象的<code>key</code>来获取<code>value</code>时，就会触发[[Get]]操作；</li>
<li>这个操作首先会在对象本身进行寻找，如果有的话就使用它；</li>
<li>没有的话就在对象的[[prototype]]属性指向的对象中寻找，如果还没有的话就继续找对象[[prototype]]属性指向的对象的[[prototype]]属性指向的对象中寻找，直到找到或者找不到为止。</li>
</ul>
<p><strong>获取对象原型的方法</strong></p>
<ol>
<li><code>__proto__</code>属性<blockquote>
<p>obj.<strong>proto</strong><br>这种方式存在浏览器的兼容性问题，所以不建议使用；</p>
</blockquote>
</li>
<li>getPrototypeOf()<blockquote>
<p>Object.getPrototypeOf(obj)<br>同样的，设置原型可使用setPrototypeOf(对象，对象要指向的原型)方法；</p>
</blockquote>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;prototype&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getPrototypeOf</span>(obj));</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span> === <span class="title class_">Object</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="1-2-ES5-–-构造函数的原型"><a href="#1-2-ES5-–-构造函数的原型" class="headerlink" title="1.2 ES5 – 构造函数的原型"></a>1.2 ES5 – <strong>构造函数</strong>的原型</h2><p>函数本身也是对象，它身上有一个<code>[[prototype]]</code>属性，这个属性是一个对象，这个对象就是函数的实例对象。</p>
<p>区别于对象的获取方式，函数的<code>[[prototype]]</code>属性是<strong>显式原型</strong>，而函数对象的<code>__proto__</code>是<strong>隐式原型</strong>；</p>
<p>通过<code>new</code>关键字创建对象：</p>
<ol>
<li>创建空对象；</li>
<li>将空对象赋值给this；</li>
<li>将对象的显式原型赋值给隐式原型；</li>
</ol>
<p><strong>案例:</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">studying</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; is studying&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;xuexi&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;student&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">studying</span> === s2.<span class="property">studying</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>若这样定义函数，那么每次通过<code>new</code>创建对象时都会创建一个新的<code>studying</code>方法；</li>
<li>但若是将该方法定义在<code>Student.prototype</code>对象中，那么<code>studying</code>方法只会创建一次，所有对象实例都会共享这个方法。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">studying</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; is studying&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;xuexi&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"><span class="keyword">const</span> s2 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&#x27;student&#x27;</span>, <span class="number">18</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">studying</span> === s2.<span class="property">studying</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>函数的显式原型对象<code>[[prototype]]</code>上有一个<code>[[constructor]]</code>属性，和这个属性指向函数本身。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span> === <span class="title class_">Student</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><strong>案例：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;p1&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="keyword">const</span> p2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;p2&#x27;</span>, <span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">running</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; is running&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="../../img/js高级/07-prototype/img.png" alt="">

<p>查找某个属性时，首先在对象本身中寻找，如果没有再在原型对象上寻找，如果没有再在原型对象的原型对象上（Object.prototype）寻找，直到找到或者找不到为止。</p>
<h2 id="1-3-ES5-–-重写原型对象（不推荐）"><a href="#1-3-ES5-–-重写原型对象（不推荐）" class="headerlink" title="1.3 ES5 – 重写原型对象（不推荐）"></a>1.3 ES5 – 重写原型对象（不推荐）</h2><p>如果要在原型对象上添加很多属性，那么我们一般会重写原型对象。</p>
<img src="../../img/js高级/07-prototype/img_2.png" alt="">

<p>我们可以通过上面的方法重写原型对象，但注意不要忘记添加<code>[[constructor]]</code>属性。</p>
<p>在重写前我们发现原型对象的<code>[[constructor]]</code>的属性描述符是不可枚举的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>))  <span class="comment">// [&#x27;running&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>但是按照我们重写的方式来看，<code>[[constructor]]</code>属性也将会被枚举，所以我们需要通过属性描述符对这个属性进行更改。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;Person&quot;</span>,</span><br><span class="line">  <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">true</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="2-原型链"><a href="#2-原型链" class="headerlink" title="2. 原型链"></a>2. 原型链</h1><h2 id="2-1-ES5-–-默认对象的原型链"><a href="#2-1-ES5-–-默认对象的原型链" class="headerlink" title="2.1 ES5 – 默认对象的原型链"></a>2.1 ES5 – 默认对象的原型链</h2><img src="../../img/js高级/07-prototype/img_3.png" alt="">

<p>当在对象身上查找某个属性时，会现在真神寻找，自身没有会在原型<code>__proto__</code>上寻找，如果没有的话会在原型的原型<code>__proto__</code>上寻找，最终查找到<code>Object.prototype</code>,它指向<code>null</code>,直到找到或者找不到为止。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="comment">// 相当于  const obj = new Object(); 构造函数的原型</span></span><br><span class="line"><span class="comment">// 即 obj.__proto__ = Object.prototype;</span></span><br></pre></td></tr></table></figure>

<h2 id="2-2-ES5-–-利用原型链实现继承"><a href="#2-2-ES5-–-利用原型链实现继承" class="headerlink" title="2.2 ES5 – 利用原型链实现继承"></a>2.2 ES5 – 利用<strong>原型链</strong>实现继承</h2><p>现定义一个<code>Person</code>类，定义一个<code>Student</code>类，实现<code>Student</code>继承<code>Person</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">say</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;hello world&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">studying</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&#x27; is studying&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ol>
<li><p>方式一 – <code>Student.prototype = Person.prototype;</code></p>
<p>这种方式会产生问题：<br>   本来只有<code>Student</code>类才有的studying方法，但是通过这种方式，<code>Student</code>类和<code>Person</code>类都拥有studying方法。也就没有实现继承。</p>
</li>
<li><p>方式二 – <code>Student.prototype = new Person();Student.prototype = p;</code></p>
<p>这种方式将<code>Student</code>类的studying方法放在<code>p</code>对象身上，而<code>Person</code>原型上没有，实现了继承。</p>
</li>
</ol>
<h2 id="2-3-ES5-–-借用构造函数实现属性继承"><a href="#2-3-ES5-–-借用构造函数实现属性继承" class="headerlink" title="2.3 ES5 – 借用构造函数实现属性继承"></a>2.3 ES5 – 借用<strong>构造函数</strong>实现属性继承</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在利用原型链实现继承的基础上</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="title class_">Person</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>,name,age)</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> student = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;chender&quot;</span>, <span class="number">22</span>)</span><br></pre></td></tr></table></figure>

<p><strong>组合继承的弊端</strong></p>
<ol>
<li>创建对象时，会调用两次父类的构造函数，一次是<code>Student.prototype = new Person();</code>，一次是<code>Student.prototype = p;</code>；</li>
<li>所有的子类实例都有两份父类的属性，一份在自身，一份在原型上；</li>
</ol>
<h2 id="2-4-ES5-–-原型式继承函数"><a href="#2-4-ES5-–-原型式继承函数" class="headerlink" title="2.4 ES5 – 原型式继承函数"></a>2.4 ES5 – 原型式继承函数</h2><p>从上面的例子中可以发现，想要实现继承就需要将父类和子类连接起来：</p>
<ol>
<li>创建新对象；</li>
<li>将新对象的原型指向父类原型；</li>
<li>子类原型指向所创建的对象；</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createObj</span>(<span class="params">o</span>)&#123;</span><br><span class="line"><span class="comment">//     无兼容性创建对象方式</span></span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">   F.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line">   </span><br><span class="line"><span class="comment">//    有兼容性创建方式：</span></span><br><span class="line"><span class="comment">//    return Object.craete(SuperType.prototype)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inderit</span>(<span class="params">SubType, SuperType</span>)&#123;</span><br><span class="line">    <span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title function_">craeteObj</span>(<span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">       <span class="attr">enumerable</span>:<span class="literal">false</span>,</span><br><span class="line">       <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">       <span class="attr">writable</span>:<span class="literal">true</span>,</span><br><span class="line">       <span class="attr">value</span>: <span class="title class_">SubType</span></span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>继承的最终写法(寄生组合式继承)：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eating</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;eating&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, sex, grade</span>) &#123;</span><br><span class="line">   <span class="title class_">Person</span>.<span class="title function_">apply</span>(<span class="variable language_">this</span>, [name, age])</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">grade</span> = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">createObj</span>(<span class="params">o</span>) &#123;</span><br><span class="line">   <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123; &#125;</span><br><span class="line">   F.<span class="property"><span class="keyword">prototype</span></span> = o</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>()</span><br><span class="line"></span><br><span class="line">   <span class="comment">//    return Object.create(o)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inherit</span>(<span class="params">SubType, SuperType</span>) &#123;</span><br><span class="line">   <span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title function_">createObj</span>(<span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>)</span><br><span class="line">   <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">      <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">      <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">      <span class="attr">value</span>: <span class="title class_">SubType</span></span><br><span class="line">   &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>补充 – 寄生式继承函数</strong></p>
<ul>
<li>寄生式(Parasitic)继承是与原型式继承紧密相关的一种思想，并且同样由道格拉斯·克罗克福德(Douglas Crockford)提出和推<br>广的；</li>
<li>寄生式继承的思路是结合原型类继承和工厂模式的一种方式；</li>
<li>即创建一个<strong>封装</strong>继承过程的函数，该函数在内部以某种方式来增强对象，最后再将这个对象返回；</li>
</ul>
<img src="../../img/js高级/07-prototype/img_1.png" alt="">

<p>从图中可以看出，<code>Student</code>继承自<code>Person</code>，同样的，<code>Person</code>也继承自<code>Object</code>，可得<font color="red"><strong><code>Object</code>是所有类的子类</strong></font>。</p>
<h2 id="2-5-ES5-–-对象补充方法"><a href="#2-5-ES5-–-对象补充方法" class="headerlink" title="2.5 ES5 – 对象补充方法"></a>2.5 ES5 – 对象补充方法</h2><ol>
<li><p>hasOwnProperty() – 判断某个属性是否存在于对象自身，而不是原型的</p>
<blockquote>
<p>obj.hasOwnProperty(“name”)</p>
</blockquote>
</li>
<li><p>in操作符 – 判断某个属性是否存在于对象身上（包括原型）</p>
<blockquote>
<p>“name” in obj</p>
</blockquote>
<p>for…in 可遍历对象的所有可枚举属性，包括原型上的属性</p>
</li>
<li><p>instanceof – 用于检测构造函数的<code>prototype</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age</span>) &#123;&#125;</span><br><span class="line"><span class="title function_">inherit</span>(<span class="title class_">Student</span>, <span class="title class_">Person</span>)</span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;chender&quot;</span>, <span class="number">22</span>)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p <span class="keyword">instanceof</span> <span class="title class_">Student</span>) <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p <span class="keyword">instanceof</span> <span class="title class_">Person</span>)  <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p <span class="keyword">instanceof</span> <span class="title class_">Object</span>)  <span class="comment">// true</span></span><br></pre></td></tr></table></figure></li>
<li><p>isPrototypeof() – 用于判断某个对象是否出现在某个实例对象的原型链上 （了解即可）</p>
<blockquote>
<p>Student.prototype.isPrototypeof(p)   &#x2F;&#x2F; p是否在Student.prototype的原型链上</p>
</blockquote>
</li>
</ol>
<h1 id="3-原型关系"><a href="#3-原型关系" class="headerlink" title="3. 原型关系"></a>3. 原型关系</h1><h2 id="3-1-原型继承关系图"><a href="#3-1-原型继承关系图" class="headerlink" title="3.1 原型继承关系图"></a>3.1 原型继承关系图</h2><img src="../../img/js高级/07-prototype/javascript_layout_tree.png" alt="javascript_layout_tree">
图片来源：<a href="http://mollypages.org/tutorials/js.mp" >javascript_layout_tree</a>

<p><strong>注：</strong></p>
<ol>
<li><strong>所有函数（比如Person， Object）都是Function的实例对象</strong>；</li>
<li>Function也是Function的实例对象；</li>
<li>原型对象创建时默认其隐式原型指向Object的显式原型；</li>
<li>推导得：Object是Person, Function的父类</li>
</ol>
<p><strong>补充 – 构造函数的类方法和实例方法：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eating</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;eating&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类方法</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property">randomPerson</span> = <span class="keyword">function</span> (<span class="params"></span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;abc&quot;</span>, <span class="number">18</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;name&quot;</span>, <span class="number">18</span>)</span><br></pre></td></tr></table></figure>
<p>有了上面这段代码，现在来思考一个问题：</p>
<ol>
<li><blockquote>
<p>Person.eating() 会执行吗？</p>
</blockquote>
<blockquote>
<p>答案是 不会。</p>
<ul>
<li>因为Person是Function的实例对象，是Object，且Person原型上没有eating方法，接着在Object原型上找也没有找到，所以会报错。</li>
<li>这种定义在构造函数原型上的方法就叫做实例方法（只有创建实例对象才能调用）。</li>
</ul>
</blockquote>
</li>
<li><blockquote>
<p>const p &#x3D; Person.randomPerson() 会执行吗？</p>
</blockquote>
<blockquote>
<p>答案是 会。</p>
<ul>
<li>因为randomPerson方法在Person对象身上，直接调用即可获得；</li>
<li>这种定义在构造函数对象上的方法就叫做类方法。</li>
</ul>
</blockquote>
</li>
</ol>
<h2 id="3-2-ES6的class"><a href="#3-2-ES6的class" class="headerlink" title="3.2 ES6的class"></a>3.2 ES6的<code>class</code></h2><h3 id="3-2-1-class定义类"><a href="#3-2-1-class定义类" class="headerlink" title="3.2.1 class定义类"></a>3.2.1 class定义类</h3><p><code>ES6</code>新的标准中使用class关键字定义类。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 实例方法</span></span><br><span class="line">    <span class="comment">// 本质是Person.prototype.eating = function()&#123;&#125;</span></span><br><span class="line">    <span class="title function_">eating</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;eating&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//     类方法</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">sleeping</span>(<span class="params"></span>)&#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;sleeping&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>class方式定义类，创建对象和构造函数方式定义类创建对象本质上是一样，但class定义的类不能作为普通函数进行调用：</p>
<h3 id="3-2-2-访问器"><a href="#3-2-2-访问器" class="headerlink" title="3.2.2 访问器"></a>3.2.2 访问器</h3><p>如何更灵活的对对象或者类的属性进行管理？我们可以使用<code>访问器</code>来实现。</p>
<ol>
<li><p>对象访问器</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">   <span class="string">&quot;_name&quot;</span>: <span class="string">&quot;chen&quot;</span>,</span><br><span class="line">   <span class="keyword">get</span> <span class="title function_">name</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">_name</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">_name</span> = value</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以使用Object.defineProperty()进行访问器定义</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">   <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">   <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">   <span class="title function_">get</span>(<span class="params"></span>)&#123;&#125;,</span><br><span class="line">   <span class="title function_">set</span>(<span class="params">value</span>)&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>类访问器</p>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">   <span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">get</span> <span class="title function_">name</span>()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">name</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">set</span> <span class="title function_">name</span>(<span class="params">value</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = value</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-3-extends实现继承"><a href="#3-3-extends实现继承" class="headerlink" title="3.3 extends实现继承"></a>3.3 extends实现继承</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">name</span> = name</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">say</span>(<span class="params"></span>)&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span>&#123;</span><br><span class="line">    <span class="title function_">constructor</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">        <span class="variable language_">super</span>(name)</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">age</span> = age</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>class中的<code>super</code>关键字：</strong></p>
<ol>
<li>super.method(…) 来调用一个父类方法；</li>
<li>super(…) 来调用父类的constructor(…)</li>
</ol>
<p>注：</p>
<ol>
<li>在子类中使用<code>this</code>或者返回默认对象前必须先通过<code>super</code>调用父类构造函数；</li>
<li><code>super</code>的使用位置：构造函数、实例方法、类方法；</li>
<li><code>super</code>只能调用同名函数，不能调用不同名函数；<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Person</span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">static</span> <span class="title function_">sleep</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="variable language_">super</span>.<span class="title function_">sleep</span>()</span><br><span class="line">        <span class="comment">// super.eat()   // 报错</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;sleeping&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>js高级</category>
      </categories>
      <tags>
        <tag>原型</tag>
      </tags>
  </entry>
  <entry>
    <title>TypeScript的默认之处</title>
    <url>/posts/2194d207.html</url>
    <content><![CDATA[<p>今天学习封装<code>axios</code>，<code>coderwhy</code>老师的封装简直不要太🐂🍺，给我看的一愣一愣的。说实话之前写的项目只是简单的封装了<code>axios</code>，导致每次使用获取到接口数都会有ts类型提示，这真的很烦人。<br>不过今天看到使用<code>ts</code>泛型定义返回数据，真是给我整爽了❗️</p>
<p>鉴于自己确实缺乏<code>ts</code>灵活的使用，所以先来回顾一下必要的基础知识🧀</p>
<h1 id="1-泛型"><a href="#1-泛型" class="headerlink" title="1. 泛型"></a>1. 泛型</h1>]]></content>
      <categories>
        <category>TypeScript</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title>06-javascript函数和对象增强</title>
    <url>/posts/2f741396.html</url>
    <content><![CDATA[<p>了解一下<code>js</code>函数和对象的相关增强知识。</p>
<h1 id="1-javascript函数增强"><a href="#1-javascript函数增强" class="headerlink" title="1. javascript函数增强"></a>1. javascript函数增强</h1><h2 id="1-1-函数基本概念掌握"><a href="#1-1-函数基本概念掌握" class="headerlink" title="1.1 函数基本概念掌握"></a>1.1 函数基本概念掌握</h2><h3 id="1-1-1-函数对象的属性"><a href="#1-1-1-函数对象的属性" class="headerlink" title="1.1.1 函数对象的属性"></a>1.1.1 函数对象的属性</h3><p>现定义一个函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>自定义属性 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">foo.<span class="property">title</span> = <span class="string">&quot;foo title&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(foo.<span class="property">title</span>) <span class="comment">// foo title</span></span><br></pre></td></tr></table></figure></li>
<li>默认属性<ul>
<li><code>name</code><br> <code>console.log(foo.name) // foo</code></li>
<li><code>length</code> (指的是函数参数的个数,但不包括有默认值的参数和可变参数)<br><code>console.log(foo.length) // 2</code></li>
</ul>
</li>
</ol>
<h3 id="1-1-2-函数的arguments"><a href="#1-1-2-函数的arguments" class="headerlink" title="1.1.2 函数的arguments"></a>1.1.2 函数的<code>arguments</code></h3><ol>
<li><p>三种获取方式</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo1</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">   <span class="comment">// 获取arguments</span></span><br><span class="line">   <span class="comment">// 1. arguments是一个伪数组对象，可通过[]字面量继续进行获取</span></span><br><span class="line">   <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2.for循环遍历</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">arguments</span>[i]);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. for of 遍历   （for of 可用来遍历可迭代对象）</span></span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="variable language_">arguments</span>) &#123;</span><br><span class="line">       <span class="variable language_">console</span>.<span class="title function_">log</span>(item);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>三种转换为数组的方式</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo2</span>(<span class="params">a, b</span>)&#123;</span><br><span class="line">   <span class="comment">// 转换成数组</span></span><br><span class="line">   <span class="comment">// 1. 将数据放入新数组</span></span><br><span class="line">   <span class="keyword">let</span> arr1 = []</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="variable language_">arguments</span>.<span class="property">length</span>; i++) &#123;</span><br><span class="line">       arr1.<span class="title function_">push</span>(<span class="variable language_">arguments</span>[i])</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. [].slice()</span></span><br><span class="line">   <span class="keyword">let</span> arr2 = [].<span class="property">slice</span>.<span class="title function_">call</span>(<span class="variable language_">arguments</span>)</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 3. Array.from()</span></span><br><span class="line">   <span class="keyword">let</span> arr3 = <span class="title class_">Array</span>.<span class="title function_">from</span>(<span class="variable language_">arguments</span>)</span><br><span class="line">   <span class="keyword">let</span> arr4 = [...<span class="variable language_">arguments</span>]</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="1-1-3-箭头函数的arguments"><a href="#1-1-3-箭头函数的arguments" class="headerlink" title="1.1.3 箭头函数的arguments"></a>1.1.3 箭头函数的<code>arguments</code></h3><p>箭头函数没有<code>arguments</code>，若在箭头函数内部使用，那么<code>arguments</code>将会向外寻找父级作用域的<code>arguments</code></p>
<h3 id="1-1-4-函数的剩余参数rest"><a href="#1-1-4-函数的剩余参数rest" class="headerlink" title="1.1.4 函数的剩余参数rest"></a>1.1.4 函数的剩余参数<code>rest</code></h3><p>如果最后一个参数以…为前缀，那么该参数将以数组的形式接收剩余的参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">rest</span>(<span class="params">a, ...args</span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a)</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(args)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">rest</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>) <span class="comment">// 1 [2,3,4,5]</span></span><br></pre></td></tr></table></figure>

<p><strong>注：剩余参数必须放在最后一个形参位置，否则会报错。</strong></p>
<p>剩余参数<code>rest</code>和<code>arguments</code>的区别：</p>
<ol>
<li><code>rest</code>以数组形式接收参数，<code>arguments</code>以伪数组对象形式接收参数；</li>
<li><code>rest</code>接收没有对应形参的实参，<code>arguments</code>接收所有实参</li>
<li><code>arguments</code>是早期<code>ECMAScript</code>为方便获取参数定义的一个属性，而<code>rest</code>是<code>ECMAScript6</code>新增的希望替代arguments的语法，。</li>
</ol>
<h2 id="1-2-纯函数"><a href="#1-2-纯函数" class="headerlink" title="1.2 纯函数"></a>1.2 纯函数</h2><h3 id="1-2-2-概念理解"><a href="#1-2-2-概念理解" class="headerlink" title="1.2.2 概念理解"></a>1.2.2 概念理解</h3><blockquote>
<p>简单来说，满足有相同输入时总是有相同输出，并且没有任何副作用的函数叫做纯函数。</p>
</blockquote>
<ol>
<li>输入相同时有相同输出<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add1</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个函数就不是一个纯函数，因为函数内部存在外部变量b，输出可能不一致。</li>
<li>没有产生任何副作用<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a,b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">add1</span>(<span class="params">a,b</span>)&#123;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这个函数修改了外部变量b，也就是产生了副作用，所以这个函数也不是纯函数。</li>
</ol>
<h3 id="1-2-2-纯函数案例"><a href="#1-2-2-纯函数案例" class="headerlink" title="1.2.2 纯函数案例"></a>1.2.2 纯函数案例</h3><blockquote>
<p>let arr &#x3D; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
</blockquote>
<ul>
<li><code>slice()</code><blockquote>
<p>console.log(arr.slice(0, 5), arr);   &#x2F;&#x2F;截取数组</p>
</blockquote>
</li>
</ul>
<p>输出：[1, 2, 3, 4, 5]   [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]</p>
<ul>
<li><code>splice()</code><blockquote>
<p>console.log(arr.splice(0, 5), arr);</p>
</blockquote>
</li>
</ul>
<p>输出：[ 1, 2, 3, 4, 5 ] [ 6, 7, 8, 9, 10 ]</p>
<p>根据输出结果可以知道slice()是纯函数，但splice()不是纯函数，因为splice()修改了arr，产生了外部影响。</p>
<p><strong>纯函数在函数式编程中很重要，它保证了函数的纯度，只单纯实现自己的业务逻辑，不会对外部变量产生影响。</strong></p>
<h2 id="1-3-函数柯里化"><a href="#1-3-函数柯里化" class="headerlink" title="1.3 函数柯里化"></a>1.3 函数柯里化</h2><h2 id="1-3-1-基本了解"><a href="#1-3-1-基本了解" class="headerlink" title="1.3.1 基本了解"></a>1.3.1 基本了解</h2><blockquote>
<p><code>柯里化（Currying）</code>是把接受多个参数的函数变换成接受一个参数的函数，并且返回接受多个参数的函数的函数。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b + c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>柯里化后：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">b</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">c</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> a + b + c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>)(<span class="number">2</span>)(<span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>箭头函数写法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">foo</span> = a =&gt; <span class="function"><span class="params">b</span> =&gt;</span> <span class="function"><span class="params">c</span> =&gt;</span> a + b + c;</span><br></pre></td></tr></table></figure>

<p>柯里化优势：</p>
<ul>
<li>职责单一</li>
<li>参数复用</li>
</ul>
<h2 id="1-4-with语句和eval函数的使用（了解即可）"><a href="#1-4-with语句和eval函数的使用（了解即可）" class="headerlink" title="1.4 with语句和eval函数的使用（了解即可）"></a>1.4 with语句和eval函数的使用（了解即可）</h2><ol>
<li><code>with</code>语句  –  可以访问对象属性<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zf&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="attr">height</span>: <span class="number">1.88</span>,</span><br><span class="line">    <span class="attr">address</span>: <span class="string">&#x27;北京&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">with</span> (obj) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(name, age, height, address);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><code>eval</code>函数  –  可将字符串转换成可执行的js语句<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> testStr = <span class="string">&#x27;全局变量&#x27;</span></span><br><span class="line"><span class="keyword">const</span> str = <span class="string">&quot;const msg = &#x27;hello world&#x27;;console.log(msg);console.log(testStr);&quot;</span></span><br><span class="line"><span class="built_in">eval</span>(str)</span><br></pre></td></tr></table></figure>
不建议在开发中使用<code>eval</code>函数：</li>
</ol>
<ul>
<li>可读性差</li>
<li>字符串容易被篡改，可能造成被攻击的风险；</li>
<li>eval的执行需要经过javascript解释器，不能优化</li>
</ul>
<h2 id="1-5-严格模式"><a href="#1-5-严格模式" class="headerlink" title="1.5 严格模式"></a>1.5 严格模式</h2><h3 id="1-5-1-严格模式的理解"><a href="#1-5-1-严格模式的理解" class="headerlink" title="1.5.1 严格模式的理解"></a>1.5.1 严格模式的理解</h3><p>长久以来，javascript不断发展，且没有出现兼容性问题，新特性的加入也会兼容旧代码，但是一些错误或者不完善的地方仍然被保留；<br>在ECMAScript5中，<code>严格模式</code>被提出，在严格模式下：</p>
<ul>
<li>严格模式下，一些静默错误会被抛出；</li>
<li>js解释器会对代码进行更多的优化；</li>
<li>（禁用一些可能在ECMAScript未来版本中的语法）</li>
</ul>
<p><strong>严格模式的开启</strong><br>在<code>script</code>标签、js文件或函数中使用<code>use strict</code>开启严格模式</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="string">&quot;use strict&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注：</p>
<ul>
<li>在<code>class</code>、<code>module</code>等模块中默认启用严格模式；</li>
<li>打包过后的文件默认也是严格模式；</li>
</ul>
<h3 id="1-5-2-严格模式的一些限制"><a href="#1-5-2-严格模式的一些限制" class="headerlink" title="1.5.2 严格模式的一些限制"></a>1.5.2 严格模式的一些限制</h3><ol>
<li><p>严格模式无法意外创建全局变量</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    message = <span class="string">&#x27;xuexi javascript&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message) <span class="comment">// 报错：message is not defined</span></span><br></pre></td></tr></table></figure></li>
<li><p>静默操作抛出异常</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;zf&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;name&quot;</span>,&#123;</span><br><span class="line">    <span class="attr">writable</span>:<span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>:<span class="literal">false</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">obj.<span class="property">name</span>=<span class="string">&#x27;xuexi&#x27;</span>  <span class="comment">//  Cannot assign to read only property &#x27;name&#x27; of object &#x27;#&lt;Object&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">name</span>   <span class="comment">//  Cannot delete property &#x27;name&#x27; of #&lt;Object&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数形参名称不能相同</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo1</span>(<span class="params">num, num</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> num + num</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">foo1</span>(<span class="number">1</span>, <span class="number">1</span>));  <span class="comment">// Duplicate parameter name not allowed in this context</span></span><br></pre></td></tr></table></figure></li>
<li><p>严格模式不允许函数参数有相同的名称</p>
</li>
<li><p>不允许0的八进制语法</p>
</li>
<li><p>在严格模式下，不允许使用with</p>
</li>
<li><p>在严格模式下，eva不再为上层引用变量</p>
</li>
<li><p>严格模式下，this绑定不会默认转为对象</p>
</li>
</ol>
<h1 id="2-javascript对象增强"><a href="#2-javascript对象增强" class="headerlink" title="2. javascript对象增强"></a>2. javascript对象增强</h1><h2 id="2-1-属性描述符"><a href="#2-1-属性描述符" class="headerlink" title="2.1 属性描述符"></a>2.1 属性描述符</h2><table>
<thead>
<tr>
<th>属性描述符</th>
<th>configurable</th>
<th>enumerable</th>
<th>writable</th>
<th>value</th>
<th>get</th>
<th>set</th>
</tr>
</thead>
<tbody><tr>
<td>数据属性描述符</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>存取属性描述符</td>
<td>可以</td>
<td>可以</td>
<td>-</td>
<td>-</td>
<td>可以</td>
<td>可以</td>
</tr>
</tbody></table>
<ol>
<li><p>数据属性描述符 （默认都为true）</p>
<ul>
<li><code>[configurable]</code>  – 是否可以删除属性，是否可以修改属性，或者是否可以修改为存取属性描述符;</li>
<li><code>[enumerable]</code>  – 是否可以枚举，即是否可以通过for..in 或者Object.keys()获取到属性;</li>
<li><code>[writable]</code> – 是否可以修改数据;</li>
<li><code>[value]</code> – 是否可以返回属性值;</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line"> <span class="attr">name</span>:<span class="string">&#x27;xuexi&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">     <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">     <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">     <span class="attr">enumerable</span>: <span class="literal">true</span>,</span><br><span class="line">     <span class="attr">value</span>: <span class="string">&#x27;xuexi&#x27;</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li><p>存取属性描述符</p>
<ul>
<li><code>[configurable]</code>  – 是否可以删除属性，是否可以修改属性，或者是否可以修改为存取属性描述符;</li>
<li><code>[enumerable]</code>  – 是否可以枚举，即是否可以通过for..in 或者Object.keys()获取到属性;</li>
<li><code>[get]</code> – 获取属性值,默认为undefined;</li>
<li><code>[set]</code> – 设置属性值,默认为undefined;</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getter&#x27;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>同时定义多个属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(obj, &#123;</span><br><span class="line">    <span class="attr">name</span>: &#123;</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">get</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;getter&#x27;</span>);&#125;,</span><br><span class="line">        <span class="attr">set</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;setter&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;&#125;)</span><br></pre></td></tr></table></figure>

<p><strong>其他属性</strong>(了解即可)</p>
<ol>
<li>获取对象属性的属性描述符<ul>
<li><code>Object.getOwnPropertyDescriptor(obj, &#39;name&#39;)</code>  – 获取对象的单个属性的属性描述符<br><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(obj, <span class="string">&#x27;name&#x27;</span>));</span><br><span class="line"><span class="comment">// 输出：&#123;</span></span><br><span class="line"><span class="comment">//    value: &#x27;xuexi&#x27;,</span></span><br><span class="line"><span class="comment">//            writable: true,</span></span><br><span class="line"><span class="comment">//         enumerable: true,</span></span><br><span class="line"><span class="comment">//         configurable: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></li>
<li><code>Object.getOwnPropertyDescriptors(obj, &#39;name&#39;)</code>  – 获取对象全部属性的属性描述符</li>
</ul>
</li>
<li>阻止对象的扩展<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 阻止扩展</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">preventExtensions</span>(obj)</span><br><span class="line">obj.<span class="property">address</span> = <span class="string">&#x27;beijing&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br></pre></td></tr></table></figure></li>
<li>密封对象 – 禁止删除操作<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 密封对象</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">seal</span>(obj)</span><br><span class="line"><span class="keyword">delete</span> obj.<span class="property">name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br></pre></td></tr></table></figure></li>
<li>冻结对象 – 禁止修改操作<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 冻结对象</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">freeze</span>(obj)</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;renzhenxuexi&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj);</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <categories>
        <category>js高级</category>
      </categories>
      <tags>
        <tag>javascript函数和对象增强</tag>
      </tags>
  </entry>
  <entry>
    <title>craco更改webpack配置</title>
    <url>/posts/89b86ab2.html</url>
    <content><![CDATA[<p><code>React</code>官方文档推荐使用<code>CRA ( create-react-app )</code>来创建项目，其中会隐藏起有关<code>webpack</code>的配置，可以通过<code>npm run eject</code>修改相关配置，但是这个操作时不可逆的❗️也就是说一旦执行了此操作，那么<code>webpack</code>相关的处理都需要自行进行处理，比如说配置、构建等。对于小白来说，还是不要轻易尝试的好。</p>
<p>如果想要<strong>配置路径别名</strong>或者<strong>less</strong>等操作时，可以通过<code>craco</code>进行配置。</p>
<p>首先安装<code>craco</code></p>
<blockquote>
<p>npm i @craco&#x2F;craco</p>
</blockquote>
<h1 id="配置less"><a href="#配置less" class="headerlink" title="配置less"></a>配置less</h1><blockquote>
<p>npm i croco-less -D</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title class_">CracoLessPlugin</span> = <span class="built_in">require</span>(<span class="string">&#x27;craco-less&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ... </span></span><br><span class="line">  <span class="attr">plugins</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">plugin</span>: <span class="title class_">CracoLessPlugin</span>,</span><br><span class="line">      <span class="attr">options</span>: &#123;</span><br><span class="line">        <span class="attr">lessLoaderOptions</span>: &#123; <span class="comment">// 配置可以参照webpack的less-loader具体配置</span></span><br><span class="line">          <span class="attr">lessOptions</span>: &#123;</span><br><span class="line">            <span class="attr">javascriptEnabled</span>: <span class="literal">true</span> <span class="comment">// 允许less文件中使用js表达式</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="移动端自适应-postcss-pxtorem"><a href="#移动端自适应-postcss-pxtorem" class="headerlink" title="移动端自适应 postcss-pxtorem"></a>移动端自适应 postcss-pxtorem</h1><blockquote>
<p>npm i postcss-pxtorem -D</p>
</blockquote>
<ul>
<li>在入口文件<code>index.ts</code>中引入</li>
</ul>
<blockquote>
<p>import ‘lib-flexible’;</p>
</blockquote>
<ul>
<li>配置<code>postcss-pxtorem</code></li>
</ul>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> postcssPx2Rem = <span class="built_in">require</span>(<span class="string">&#x27;postcss-pxtorem&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="attr">style</span>: &#123;</span><br><span class="line">        <span class="attr">postcss</span>: &#123;</span><br><span class="line">          <span class="attr">mode</span>: <span class="string">&#x27;extends&#x27;</span>,</span><br><span class="line">          <span class="attr">loaderOptions</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">              <span class="attr">postcssOptions</span>: &#123;</span><br><span class="line">                <span class="attr">ident</span>: <span class="string">&#x27;postcss&#x27;</span>,</span><br><span class="line">                <span class="attr">config</span>: <span class="literal">false</span>,</span><br><span class="line">                <span class="attr">plugins</span>: [</span><br><span class="line">                  <span class="title function_">postcssPx2Rem</span>(&#123;</span><br><span class="line">                    <span class="attr">rootValue</span>: <span class="number">37.5</span>, <span class="comment">// 设计稿尺寸/10</span></span><br><span class="line">                    <span class="attr">propList</span>: [<span class="string">&#x27;*&#x27;</span>], <span class="comment">// 需要转换的样式属性，默认为 [&#x27;*&#x27;]，即匹配所有属性</span></span><br><span class="line">                    <span class="attr">exclude</span>: <span class="regexp">/node_modules/i</span> <span class="comment">// 排除掉node_modules中转换</span></span><br><span class="line">                  &#125;)</span><br><span class="line">                ]</span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">sourceMap</span>: <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// craco.config.js文件</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="attr">devServer</span>: &#123;</span><br><span class="line">        <span class="attr">port</span>: <span class="number">8888</span>,</span><br><span class="line">        <span class="attr">hot</span>: <span class="literal">true</span>,</span><br><span class="line">        <span class="attr">client</span>: &#123;</span><br><span class="line">          <span class="attr">overlay</span>: <span class="literal">false</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="comment">// 配置代理解决跨域</span></span><br><span class="line">        <span class="attr">proxy</span>: &#123;</span><br><span class="line">          <span class="string">&#x27;/&#x27;</span>: &#123;</span><br><span class="line">            <span class="attr">target</span>: process.<span class="property">env</span>.<span class="property">REACT_APP_URL</span>, <span class="comment">// https://xxx.com</span></span><br><span class="line">            <span class="attr">changeOrigin</span>: <span class="literal">true</span>,</span><br><span class="line">            <span class="attr">pathRewrite</span>: &#123;</span><br><span class="line">              <span class="string">&#x27;^/&#x27;</span>: <span class="string">&#x27;&#x27;</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="路径别名和打包大小分析"><a href="#路径别名和打包大小分析" class="headerlink" title="路径别名和打包大小分析"></a>路径别名和打包大小分析</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"> <span class="comment">// craco.config.js文件</span></span><br><span class="line"><span class="keyword">const</span> &#123; <span class="title class_">BundleAnalyzerPlugin</span> &#125; = <span class="built_in">require</span>(<span class="string">&#x27;webpack-bundle-analyzer&#x27;</span>)</span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="attr">webpack</span>: &#123;</span><br><span class="line">        <span class="comment">// 配置别名</span></span><br><span class="line">        <span class="attr">alias</span>: &#123;</span><br><span class="line">            <span class="comment">// 约定：使用 @ 表示 src 文件所在路径</span></span><br><span class="line">            <span class="string">&#x27;@&#x27;</span>: path.<span class="title function_">resolve</span>(__dirname, <span class="string">&#x27;src&#x27;</span>)</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="attr">plugins</span>: [</span><br><span class="line">            <span class="comment">// 打包分析插件，需要分析时解开注释</span></span><br><span class="line">            <span class="comment">// [new BundleAnalyzerPlugin()]</span></span><br><span class="line">        ],</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="拆包和打包路径"><a href="#拆包和打包路径" class="headerlink" title="拆包和打包路径"></a>拆包和打包路径</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// craco.config.js文件</span></span><br><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="attr">webpack</span>: &#123;</span><br><span class="line">    <span class="attr">configure</span>: <span class="function"><span class="params">webpackConfig</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="comment">// 生产环境配置</span></span><br><span class="line">      <span class="keyword">if</span> (isProd) &#123;</span><br><span class="line">        <span class="comment">// 去除map文件</span></span><br><span class="line">        webpackConfig.<span class="property">devtool</span> = <span class="literal">false</span></span><br><span class="line">        <span class="comment">// 拆包</span></span><br><span class="line">        webpackConfig.<span class="property">optimization</span> = &#123;</span><br><span class="line">          <span class="attr">splitChunks</span>: &#123;</span><br><span class="line">            <span class="attr">chunks</span>: <span class="string">&#x27;async&#x27;</span>,</span><br><span class="line">            <span class="attr">minSize</span>: <span class="number">40000</span>, <span class="comment">// bite</span></span><br><span class="line">            <span class="attr">maxAsyncRequests</span>: <span class="number">10</span>, <span class="comment">// 最大异步请求数</span></span><br><span class="line">            <span class="attr">maxInitialRequests</span>: <span class="number">10</span>, <span class="comment">// 页面初始化最大异步请求数</span></span><br><span class="line">            <span class="attr">automaticNameDelimiter</span>: <span class="string">&#x27;~&#x27;</span>, <span class="comment">// 解决命名冲突</span></span><br><span class="line">            <span class="attr">name</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">cacheGroups</span>: &#123;</span><br><span class="line">              <span class="attr">antd</span>: &#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;chunk-antd&#x27;</span>,</span><br><span class="line">                <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/](@ant-design|antd-mobile)[\\/]/</span>,</span><br><span class="line">                <span class="attr">priority</span>: -<span class="number">7</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">common</span>: &#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;chunk-common&#x27;</span>,</span><br><span class="line">                <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/](react|react-dom|react-router|react-redux|react-router-dom|redux-persist|react-fastclick)[\\/]/</span>,</span><br><span class="line">                <span class="attr">priority</span>: -<span class="number">9</span></span><br><span class="line">              &#125;,</span><br><span class="line">              <span class="attr">vendor</span>: &#123;</span><br><span class="line">                <span class="attr">name</span>: <span class="string">&#x27;chunk-vendor&#x27;</span>,</span><br><span class="line">                <span class="attr">chunks</span>: <span class="string">&#x27;all&#x27;</span>,</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/[\\/]node_modules[\\/](axios|lodash|core-js|react-copy-to-clipboard|crypto-js|web-vitals)[\\/]/</span>,</span><br><span class="line">                <span class="attr">priority</span>: -<span class="number">10</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 输出output</span></span><br><span class="line">        webpackConfig.<span class="property">output</span> = &#123;</span><br><span class="line">          ...webpackConfig.<span class="property">output</span>,</span><br><span class="line">          <span class="attr">publicPath</span>: <span class="string">&#x27;./&#x27;</span> <span class="comment">// 打包资源引入路径--目前使用的是相对路径</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> webpackConfig</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="移除开发日志console-log"><a href="#移除开发日志console-log" class="headerlink" title="移除开发日志console.log"></a>移除开发日志console.log</h1><figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">module</span>.<span class="property">exports</span> = &#123;</span><br><span class="line">     <span class="attr">babel</span>: &#123;</span><br><span class="line">        <span class="attr">plugins</span>: [</span><br><span class="line">          <span class="comment">// 生产环境只留console.error、warn，去除console.log</span></span><br><span class="line">          [</span><br><span class="line">            <span class="string">&#x27;babel-plugin-transform-remove-console&#x27;</span>,</span><br><span class="line">            &#123; <span class="attr">exclude</span>: isProd ? [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;warn&#x27;</span>] : [<span class="string">&#x27;error&#x27;</span>, <span class="string">&#x27;warn&#x27;</span>, <span class="string">&#x27;log&#x27;</span>] &#125;</span><br><span class="line">          ]</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="修改项目运行命令"><a href="#修改项目运行命令" class="headerlink" title="修改项目运行命令"></a>修改项目运行命令</h1><p><code>package.json</code></p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;start&quot;</span>: <span class="string">&quot;craco start&quot;</span>,</span><br><span class="line">        <span class="string">&quot;build&quot;</span>: <span class="string">&quot;craco build&quot;</span>,</span><br><span class="line">        <span class="string">&quot;test&quot;</span>: <span class="string">&quot;craco test&quot;</span>,</span><br><span class="line">        <span class="string">&quot;eject&quot;</span>: <span class="string">&quot;react-scripts eject&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="加载开发、测试、生产不同环境的环境变量"><a href="#加载开发、测试、生产不同环境的环境变量" class="headerlink" title="加载开发、测试、生产不同环境的环境变量"></a>加载开发、测试、生产不同环境的环境变量</h1><p>使用<code>dotenv-cli</code></p>
<blockquote>
<p>npm i dotenv-cli -D</p>
</blockquote>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;prod&quot;</span>: <span class="string">&quot;dotenv -e .env.production craco start&quot;</span>,</span><br><span class="line">        <span class="string">&quot;build:dev&quot;</span>: <span class="string">&quot;dotenv -e .env.development craco build&quot;</span>,</span><br><span class="line">        <span class="string">&quot;build:test&quot;</span>: <span class="string">&quot;dotenv -e .env.test craco build&quot;</span>,</span><br><span class="line">        <span class="string">&quot;build:prod&quot;</span>: <span class="string">&quot;dotenv -e .env.production craco build&quot;</span>,</span><br><span class="line">        <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;eslint -c .eslintrc.js src --ext .ts,.tsx,.js,.jsx --fix&quot;</span>,</span><br><span class="line">        <span class="string">&quot;clean&quot;</span>: <span class="string">&quot;rimraf node_modules&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>webpack配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Nginx安装与配置以及常用命令</title>
    <url>/posts/4f72a7f4.html</url>
    <content><![CDATA[<p>了解一下Nginx的安装与配置，以及常见的Nginx常用命令</p>
<h1 id="1-安装与配置"><a href="#1-安装与配置" class="headerlink" title="1. 安装与配置"></a>1. 安装与配置</h1><ol>
<li><p>阿里云申请免费云服务器，为Nginx练习使用</p>
</li>
<li><p>连接远程服务器</p>
<ul>
<li>首先重置root密码</li>
<li>若是使用vscode 可安装 <code>remote ssh</code>插件 （用来连接远程服务器）</li>
<li>连接到远程</li>
</ul>
</li>
<li><p>下载Nginx </p>
<ul>
<li>cd &#x2F;usr&#x2F;local</li>
<li>wget <a href="https://nginx.org/download/Nginx-1.28.0.tar.gz">https://nginx.org/download/Nginx-1.28.0.tar.gz</a> (若下载不成功可通过命令 <code>su</code> 切换到root用户)</li>
</ul>
</li>
</ol>
<img src="../../img/Nginx/img.png">

<pre><code>- tar -zxvf Nginx-1.28.0.tar.gz
- cd ./Nginx-1.28.0
</code></pre>
<ol start="4">
<li>初始配置及编译安装<ul>
<li>初始配置 .&#x2F;configure</li>
<li>编译源码 安装 make &amp;&amp; make install</li>
</ul>
</li>
</ol>
<h1 id="2-Nginx常见命令"><a href="#2-Nginx常见命令" class="headerlink" title="2. Nginx常见命令"></a>2. Nginx常见命令</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">user admin; # 规定启动Nginx的用户</span><br><span class="line">worker_processes 1; # Nginx 启动一个工作进程，适用于轻量部署或开发环境。</span><br><span class="line">events &#123;</span><br><span class="line">   worker_connections 1024; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">http&#123;</span><br><span class="line">   include mime.types; # 文件类型映射</span><br><span class="line">   default_type application/octet-stream; # 默认MIME类型</span><br><span class="line">   sendfile        on;                            # 启用 sendfile 加速</span><br><span class="line">   tcp_nopush      on;                            # 优化发送数据包</span><br><span class="line">   keepalive_timeout  65;                         # 长连接超时</span><br><span class="line">   client_max_body_size 10m;                      # 请求体大小限制</span><br><span class="line"></span><br><span class="line">   include /etc/nginx/conf.d/*.conf;              # 引入子配置文件</span><br><span class="line">   </span><br><span class="line">   # 静态文件配置</span><br><span class="line">   server &#123;</span><br><span class="line">      listen 8080 ssl;</span><br><span class="line">      server_name localhost myTest.com;</span><br><span class="line">      </span><br><span class="line">      # 申请ssl证书 配置ssl证书</span><br><span class="line">      ssl_certificate /path/to/cert.pem;</span><br><span class="line">      ssl_certificate_key /path/to/cert.key;</span><br><span class="line">      </span><br><span class="line">      location / &#123;</span><br><span class="line">         root /usr/local/nginx/html/dist; # 相对静态资源路径</span><br><span class="line">         index index.html inddex.htm;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      location /api &#123;</span><br><span class="line">         # 设置CORS配置</span><br><span class="line">         add_header Access-Control-Allow-Origin *;</span><br><span class="line">         add_header Access-Control-Allow-Methods &#x27;GET, POST, OPTIONS&#x27;;</span><br><span class="line">         add_header Access-Control-Allow-Headers &#x27;Content-Type, Authorization&#x27;;</span><br><span class="line">         </span><br><span class="line">         alias /usr/local/nginx/html/dist/api; # 绝对静态资源路径</span><br><span class="line">         index index.html inddex.htm;</span><br><span class="line">         </span><br><span class="line">         if ($request_method = &#x27;OPTIONS&#x27;) &#123;</span><br><span class="line">            return 204;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title>10-Proxy-Reflect</title>
    <url>/posts/9d935f.html</url>
    <content><![CDATA[<p><code>Proxy</code>详解。</p>
<h1 id="1-Proxy"><a href="#1-Proxy" class="headerlink" title="1. Proxy"></a>1. Proxy</h1><p><strong>现在有一个问题：我们如何监听对象的操作？</strong></p>
<ol>
<li><p><code>Object.defineProperty()</code><br> 之前我们会通过<code>Object.defineProperty()</code>来进行监听，</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj.<span class="property">name</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">value</span>) &#123;</span><br><span class="line">    obj.<span class="property">name</span> = value</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>Vue2</code>实现响应式原理的核心就是通过<code>Object.defineProperty()</code>来实现的；</li>
<li>但是<code>Object.defineProperty()</code>设计之初并不是为了监听某个属性；</li>
<li>我们在定义某个属性时，初衷是定义某个普通属性，但是我们后面强行把它变成了数据属性描述符；</li>
<li>而且<code>Object.defineProperty()</code>无法监听到新增属性和删除属性等操作</li>
</ul>
</li>
<li><p>Proxy</p>
<blockquote>
<p>new Proxy(target, handler)</p>
<ul>
<li>target: 目标对象</li>
<li>handler: 处理函数</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> target[key]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newValue</span>) &#123;</span><br><span class="line">    target[key] = newValue</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">objProxy.<span class="property">name</span> = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="comment">// 之后操作obj可以通过objProxy来操作，可达到监听的目的</span></span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>对某个对象行进行其他操作时，我们通过<code>Proxy</code>也可以监听到！<br>上面我们介绍了<code>set()</code>和<code>get()</code>两种<code>handler</code>，<code>handler</code>有13种捕获器（handler）：</li>
</ul>
<p>除了上面两种常用的捕获器，还有以下两种常用的捕获器：</p>
<ul>
<li><code>has()</code>：拦截<code>in</code>操作符；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">   <span class="title function_">has</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;has&quot;</span>);</span><br><span class="line">      <span class="keyword">return</span> key <span class="keyword">in</span> target</span><br><span class="line">   &#125;,</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;in&#x27;</span>, name <span class="keyword">in</span> objProxy); <span class="comment">// in true</span></span><br></pre></td></tr></table></figure>

<ul>
<li><code>deleteProperty()</code>：拦截<code>delete</code>操作符；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="title function_">defineProperty</span>(<span class="params">target, key, descriptor</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;defineProperty&quot;</span>);</span><br><span class="line">    <span class="keyword">delete</span> target[key]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> objProxy.<span class="property">name</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(objProxy); <span class="comment">// &#123;age: 20&#125;</span></span><br></pre></td></tr></table></figure>

<p>下面几种了解即可：<br><img src="/../../img/js%E9%AB%98%E7%BA%A7/10-proxy/img.png" alt="img.png"></p>
<h1 id="2-Reflect"><a href="#2-Reflect" class="headerlink" title="2. Reflect"></a>2. Reflect</h1><p><code>Reflect</code>对象是<code>ES6</code>新增的对象。</p>
<ul>
<li><p><code>Reflect</code>主要提供了一些操作<code>javascript</code>对象的方法，跟<code>Object</code>操作对象的方法类似；</p>
<ul>
<li>比如<code>Object.defineProperty()</code>和<code>Reflect.defineProperty()</code></li>
<li><code>Object.getPrototypeOf()</code>和<code>Reflect.getPrototypeOf()</code></li>
</ul>
</li>
<li><p>早期的ECMA规范没有考虑到这种对对象的操作是否规范就将这些API加在了<code>Object</code>上；</p>
</li>
<li><p>但是<code>Object</code>作为一个构造函数，这样设计是不安全的，所以ES6中新增了<code>Rfelct</code>，把这些对对象的操作方法都集中起来；</p>
</li>
<li><p>另外，在使用<code>Proxy</code>时不操作原对象</p>
</li>
</ul>
<h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><img src="/../../img/js%E9%AB%98%E7%BA%A7/10-proxy/img2.png" alt="img.png"></p>
<p><strong><code>Reflect</code>和<code>Proxy</code>共同实现代理：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;obj&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// 默认为   this ---&gt; obj</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(obj, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, receiver</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key)</span><br><span class="line">        <span class="comment">// const result = Reflect.get(target, key, receiver)   // 将obj中set()的this指向receiver</span></span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, newValue, receiver</span>) &#123;</span><br><span class="line">        <span class="comment">// 之前  直接操作target对象</span></span><br><span class="line">        target[key] = newValue</span><br><span class="line">        <span class="comment">// 有了Reflect</span></span><br><span class="line">        <span class="keyword">const</span> result = <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue)</span><br><span class="line">        <span class="keyword">if</span> (result) &#123;</span><br><span class="line">            <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;成功&quot;</span>);</span><br><span class="line">            target[key] = newValue</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;设置失败&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用<code>Reflect</code>的好处：</p>
<ol>
<li>不再直接操作<code>target</code>对象；</li>
<li><code>Reflect</code>的set等方法会返回boolean值，可以判断是否操作成功；</li>
<li><code>Reflect.get(target, key, receiver) </code>可将obj中set()的<code>this</code>指向<strong>receiver</strong>(所创建的proxy对象)</li>
</ol>
]]></content>
      <categories>
        <category>js高级</category>
      </categories>
      <tags>
        <tag>Proxy / Reflect</tag>
      </tags>
  </entry>
  <entry>
    <title>09-let-const</title>
    <url>/posts/abd5a0df.html</url>
    <content><![CDATA[<p>let &#x2F; const 注意事项</p>
<ol>
<li><p>重复声明</p>
<ul>
<li><code>var</code> 可重复声明</li>
<li><code>let</code> &#x2F; <code>const</code> 不可重复声明</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;hello world!&#x27;</span> <span class="comment">// 不报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> address = <span class="string">&#x27;beijing&#x27;</span></span><br><span class="line"><span class="keyword">let</span> address = <span class="string">&#x27;shanghai&#x27;</span> <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">19</span>  <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>作用域提升</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> message = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(address) <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> address = <span class="string">&#x27;beijing&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age)  <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在创建执行上下文时，词法环境被创建，变量也被创建，但<code>var</code>定义的变量被初始化为<code>undefined</code>，<code>let</code>&#x2F;<code>const</code>定义的变量未赋值，访问会报错。</p>
</li>
<li><p>暂时性死区</p>
<ul>
<li>变量未被声明之前到作用域顶部，这块区域不能访问变量，会报错（叫做<code>暂时性死区</code>）。</li>
</ul>
</li>
<li><p>window对象添加属性</p>
<ul>
<li><code>var</code>定义的变量会添加在<code>window</code>对象上;</li>
<li><code>let</code>&#x2F;<code>const</code>定义的变量不会添加在<code>window</code>对象上</li>
</ul>
<img src="../../img/js高级/09-let-const/img.png" alt="">

<p>在全局语法环境中存在<code>obejct Environment Record</code> 和<code>declarative Environment Record</code>两个对象，前者是<code>window</code>对象，后者身上添加了<code>let</code>和<code>const</code>声明的变量。</p>
</li>
<li><p>块级作用域</p>
<ul>
<li><code>ES6</code>中新增了块级作用域 <code>&#123; ... &#125;</code> ，并且通过<code>let</code>、<code>const</code>、<code>function</code>、<code>class</code>声明的标识符是具备块级作用域限制的。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">     <span class="keyword">let</span> message = <span class="string">&#x27;hello world&#x27;</span></span><br><span class="line">     <span class="keyword">const</span> age = <span class="number">18</span></span><br><span class="line">     <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">         <span class="variable language_">console</span>.<span class="title function_">log</span>(message)</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">class</span> <span class="title class_">Person</span> &#123;  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中只有<code>function</code> 可以在外部被访问到，这是因为引擎会对函数的声明进行特殊的处理，允许像<code>var</code>那样可以在外接访问 。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>js高级</category>
      </categories>
      <tags>
        <tag>let-const</tag>
      </tags>
  </entry>
</search>

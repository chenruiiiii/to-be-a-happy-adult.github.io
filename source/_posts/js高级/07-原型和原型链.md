---
title: 07-原型和原型链
categories:
  - 分类
tags:
  - js高级
indexing: false
keywords: 原型和原型链
---

认识一下原型和原型链。


# 1. 认识原型

## 1.1 原型是什么？怎样获取？

### 1.1.1 对象的原型
每个对象身上都有一个[[prototype]]内置属性，这个特殊的对象可以指向另外一个对象。

- 当我们通过引用对象的`key`来获取`value`时，就会触发[[Get]]操作；
- 这个操作首先会在对象本身进行寻找，如果有的话就使用它；
- 没有的话就在对象的[[prototype]]属性指向的对象中寻找，如果还没有的话就继续找对象[[prototype]]属性指向的对象的[[prototype]]属性指向的对象中寻找，直到找到或者找不到为止。

**获取对象原型的方法**
1. `__proto__`属性
    > obj.__proto__
2. getPrototypeOf()
    > Object.getPrototypeOf(obj)
```javascript
    const obj = {
    name: 'prototype'
}

console.log(obj);

console.log(obj.__proto__);
console.log(Object.getPrototypeOf(obj));
console.log(obj.__proto__ === Object.prototype); // true
```
### 1.1.2 函数的原型

函数本身也是对象，它身上有一个`prototype`属性，这个属性是一个对象，这个对象就是函数的实例对象。

区别于对象的获取方式，函数的`prototype`属性是**显式原型**，而函数对象的`__proto__`是**隐式原型**；

通过`new`关键字创建对象：
1. 创建空对象；
2. 将空对象赋值给this；
3. 将对象的显式原型赋值给隐式原型；

**案例:**
```javascript
function Student(name, age) {
  this.name = name;
  this.age = age;

  this.studying = function () {
    console.log(this.name + ' is studying');
  }
}

const s1 = new Student('xuexi', 18);
const s2 = new Student('student', 18);

console.log(s1.studying === s2.studying); // false
```
- 若这样定义函数，那么每次通过`new`创建对象时都会创建一个新的`studying`方法；
- 但若是将该方法定义在`Student.prototype`对象中，那么`studying`方法只会创建一次，所有对象实例都会共享这个方法。

```javascript
Student.prototype.studying = function () {
  console.log(this.name + ' is studying');
}
const s1 = new Student('xuexi', 18);
const s2 = new Student('student', 18);

console.log(s1.studying === s2.studying); // true
```

函数的显式原型对象`prototype`上有一个`constructor`属性，和这个属性指向函数本身。
```javascript
console.log(Student.prototype.constructor === Student); // true
```














